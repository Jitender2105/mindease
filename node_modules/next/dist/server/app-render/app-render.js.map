{"version":3,"sources":["../../../src/server/app-render/app-render.tsx"],"sourcesContent":["import type {\n  ActionResult,\n  DynamicParamTypesShort,\n  FlightRouterState,\n  RenderOpts,\n  Segment,\n  CacheNodeSeedData,\n  PreloadCallbacks,\n  RSCPayload,\n  FlightData,\n  InitialRSCPayload,\n  FlightDataPath,\n} from './types'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { NextParsedUrlQuery } from '../request-meta'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type {\n  ClientReferenceManifest,\n  ManifestNode,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\n\nimport React, { type ErrorInfo, type JSX } from 'react'\n\nimport RenderResult, {\n  type AppPageRenderResultMetadata,\n  type RenderResultOptions,\n} from '../render-result'\nimport {\n  chainStreams,\n  renderToInitialFizzStream,\n  createDocumentClosingStream,\n  continueFizzStream,\n  continueDynamicPrerender,\n  continueStaticPrerender,\n  continueDynamicHTMLResume,\n  streamToBuffer,\n  streamToString,\n} from '../stream-utils/node-web-streams-helper'\nimport { stripInternalQueries } from '../internal-utils'\nimport {\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_URL,\n  RSC_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HASH_COOKIE,\n} from '../../client/components/app-router-headers'\nimport {\n  createTrackedMetadataContext,\n  createMetadataContext,\n} from '../../lib/metadata/metadata-context'\nimport { createRequestStoreForRender } from '../async-storage/request-store'\nimport { createWorkStore } from '../async-storage/work-store'\nimport {\n  getAccessFallbackErrorTypeByStatus,\n  getAccessFallbackHTTPStatus,\n  isHTTPAccessFallbackError,\n} from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getURLFromRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { isRedirectError } from '../../client/components/redirect-error'\nimport { getImplicitTags, type ImplicitTags } from '../lib/implicit-tags'\nimport { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  createFlightReactServerErrorHandler,\n  createHTMLReactServerErrorHandler,\n  createHTMLErrorHandler,\n  type DigestedError,\n  isUserLandError,\n  getDigestForWellKnownError,\n} from './create-error-handler'\nimport {\n  getShortDynamicParamType,\n  dynamicParamTypes,\n} from './get-short-dynamic-param-type'\nimport { getSegmentParam } from './get-segment-param'\nimport { getScriptNonceFromHeader } from './get-script-nonce-from-header'\nimport { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport { handleAction } from './action-handler'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { warn, error } from '../../build/output/log'\nimport { appendMutableCookies } from '../web/spec-extension/adapters/request-cookies'\nimport { createServerInsertedHTML } from './server-inserted-html'\nimport { getRequiredScripts } from './required-scripts'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport { makeGetServerInsertedHTML } from './make-get-server-inserted-html'\nimport { walkTreeWithFlightRouterState } from './walk-tree-with-flight-router-state'\nimport { createComponentTree, getRootParams } from './create-component-tree'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { setReferenceManifestsSingleton } from './encryption-utils'\nimport {\n  DynamicState,\n  type PostponedState,\n  parsePostponedState,\n} from './postponed-state'\nimport {\n  getDynamicDataPostponedState,\n  getDynamicHTMLPostponedState,\n  getPostponedFromState,\n} from './postponed-state'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  useFlightStream,\n  createInlinedDataReadableStream,\n} from './use-flight-response'\nimport {\n  StaticGenBailoutError,\n  isStaticGenBailoutError,\n} from '../../client/components/static-generation-bailout'\nimport { getStackWithoutErrorMessage } from '../../lib/format-server-error'\nimport {\n  accessedDynamicData,\n  createPostponedAbortSignal,\n  formatDynamicAPIAccesses,\n  isPrerenderInterruptedError,\n  createDynamicTrackingState,\n  createDynamicValidationState,\n  getFirstDynamicReason,\n  trackAllowedDynamicAccess,\n  throwIfDisallowedDynamic,\n  consumeDynamicAccess,\n  type DynamicAccess,\n} from './dynamic-rendering'\nimport {\n  getClientComponentLoaderMetrics,\n  wrapClientComponentLoader,\n} from '../client-component-renderer-logger'\nimport { createServerModuleMap } from './action-utils'\nimport { isNodeNextRequest } from '../base-http/helpers'\nimport { parseParameter } from '../../shared/lib/router/utils/route-regex'\nimport { parseRelativeUrl } from '../../shared/lib/router/utils/parse-relative-url'\nimport AppRouter from '../../client/components/app-router'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RequestErrorContext } from '../instrumentation/types'\nimport { getIsPossibleServerAction } from '../lib/server-action-request-meta'\nimport { createInitialRouterState } from '../../client/components/router-reducer/create-initial-router-state'\nimport { createMutableActionQueue } from '../../client/components/app-router-instance'\nimport { getRevalidateReason } from '../instrumentation/utils'\nimport { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  ServerPrerenderStreamResult,\n  processPrelude,\n} from './app-render-prerender-utils'\nimport {\n  type ReactServerPrerenderResult,\n  ReactServerResult,\n  createReactServerPrerenderResult,\n  createReactServerPrerenderResultFromRender,\n  prerenderAndAbortInSequentialTasks,\n  prerenderServerWithPhases,\n  prerenderClientWithPhases,\n} from './app-render-prerender-utils'\nimport { printDebugThrownValueForProspectiveRender } from './prospective-render-utils'\nimport { scheduleInSequentialTasks } from './app-render-render-utils'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStore,\n} from './work-unit-async-storage.external'\nimport { CacheSignal } from './cache-signal'\nimport { getTracedMetadata } from '../lib/trace/utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport './clean-async-snapshot.external'\nimport { INFINITE_CACHE } from '../../lib/constants'\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts'\nimport { parseLoaderTree } from './parse-loader-tree'\nimport {\n  createPrerenderResumeDataCache,\n  createRenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { MetadataErrorType } from '../../lib/metadata/resolve-metadata'\nimport isError from '../../lib/is-error'\nimport { isUseCacheTimeoutError } from '../use-cache/use-cache-errors'\nimport { createServerInsertedMetadata } from './metadata-insertion/create-server-inserted-metadata'\nimport { getPreviouslyRevalidatedTags } from '../server-utils'\nimport { executeRevalidates } from '../revalidation-utils'\n\nexport type GetDynamicParamFromSegment = (\n  // [slug] / [[slug]] / [...slug]\n  segment: string\n) => {\n  param: string\n  value: string | string[] | null\n  treeSegment: Segment\n  type: DynamicParamTypesShort\n} | null\n\nexport type GenerateFlight = typeof generateDynamicFlightRenderResult\n\nexport type AppSharedContext = {\n  buildId: string\n}\n\nexport type AppRenderContext = {\n  sharedContext: AppSharedContext\n  workStore: WorkStore\n  url: ReturnType<typeof parseRelativeUrl>\n  componentMod: AppPageModule\n  renderOpts: RenderOpts\n  parsedRequestHeaders: ParsedRequestHeaders\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  query: NextParsedUrlQuery\n  isPrefetch: boolean\n  isPossibleServerAction: boolean\n  requestTimestamp: number\n  appUsingSizeAdjustment: boolean\n  flightRouterState?: FlightRouterState\n  requestId: string\n  pagePath: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  assetPrefix: string\n  isNotFoundPath: boolean\n  nonce: string | undefined\n  res: BaseNextResponse\n  /**\n   * For now, the implicit tags are common for the whole route. If we ever start\n   * rendering/revalidating segments independently, they need to move to the\n   * work unit store.\n   */\n  implicitTags: ImplicitTags\n}\n\ninterface ParseRequestHeadersOptions {\n  readonly isDevWarmup: undefined | boolean\n  readonly isRoutePPREnabled: boolean\n  readonly previewModeId: string | undefined\n}\n\nconst flightDataPathHeadKey = 'h'\nconst getFlightViewportKey = (requestId: string) => requestId + 'v'\nconst getFlightMetadataKey = (requestId: string) => requestId + 'm'\n\ninterface ParsedRequestHeaders {\n  /**\n   * Router state provided from the client-side router. Used to handle rendering\n   * from the common layout down. This value will be undefined if the request is\n   * not a client-side navigation request, or if the request is a prefetch\n   * request.\n   */\n  readonly flightRouterState: FlightRouterState | undefined\n  readonly isPrefetchRequest: boolean\n  readonly isRouteTreePrefetchRequest: boolean\n  readonly isDevWarmupRequest: boolean\n  readonly isHmrRefresh: boolean\n  readonly isRSCRequest: boolean\n  readonly nonce: string | undefined\n  readonly previouslyRevalidatedTags: string[]\n}\n\nfunction parseRequestHeaders(\n  headers: IncomingHttpHeaders,\n  options: ParseRequestHeadersOptions\n): ParsedRequestHeaders {\n  const isDevWarmupRequest = options.isDevWarmup === true\n\n  // dev warmup requests are treated as prefetch RSC requests\n  const isPrefetchRequest =\n    isDevWarmupRequest ||\n    headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] !== undefined\n\n  const isHmrRefresh =\n    headers[NEXT_HMR_REFRESH_HEADER.toLowerCase()] !== undefined\n\n  // dev warmup requests are treated as prefetch RSC requests\n  const isRSCRequest =\n    isDevWarmupRequest || headers[RSC_HEADER.toLowerCase()] !== undefined\n\n  const shouldProvideFlightRouterState =\n    isRSCRequest && (!isPrefetchRequest || !options.isRoutePPREnabled)\n\n  const flightRouterState = shouldProvideFlightRouterState\n    ? parseAndValidateFlightRouterState(\n        headers[NEXT_ROUTER_STATE_TREE_HEADER.toLowerCase()]\n      )\n    : undefined\n\n  // Checks if this is a prefetch of the Route Tree by the Segment Cache\n  const isRouteTreePrefetchRequest =\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER.toLowerCase()] === '/_tree'\n\n  const csp =\n    headers['content-security-policy'] ||\n    headers['content-security-policy-report-only']\n\n  const nonce =\n    typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined\n\n  const previouslyRevalidatedTags = getPreviouslyRevalidatedTags(\n    headers,\n    options.previewModeId\n  )\n\n  return {\n    flightRouterState,\n    isPrefetchRequest,\n    isRouteTreePrefetchRequest,\n    isHmrRefresh,\n    isRSCRequest,\n    isDevWarmupRequest,\n    nonce,\n    previouslyRevalidatedTags,\n  }\n}\n\nfunction createNotFoundLoaderTree(loaderTree: LoaderTree): LoaderTree {\n  // Align the segment with parallel-route-default in next-app-loader\n  const components = loaderTree[2]\n  return [\n    '',\n    {\n      children: [\n        PAGE_SEGMENT_KEY,\n        {},\n        {\n          page: components['not-found'],\n        },\n      ],\n    },\n    components,\n  ]\n}\n\n/**\n * Returns a function that parses the dynamic segment and return the associated value.\n */\nfunction makeGetDynamicParamFromSegment(\n  params: { [key: string]: any },\n  pagePath: string,\n  fallbackRouteParams: FallbackRouteParams | null\n): GetDynamicParamFromSegment {\n  return function getDynamicParamFromSegment(\n    // [slug] / [[slug]] / [...slug]\n    segment: string\n  ) {\n    const segmentParam = getSegmentParam(segment)\n    if (!segmentParam) {\n      return null\n    }\n\n    const key = segmentParam.param\n\n    let value = params[key]\n\n    if (fallbackRouteParams && fallbackRouteParams.has(segmentParam.param)) {\n      value = fallbackRouteParams.get(segmentParam.param)\n    } else if (Array.isArray(value)) {\n      value = value.map((i) => encodeURIComponent(i))\n    } else if (typeof value === 'string') {\n      value = encodeURIComponent(value)\n    }\n\n    if (!value) {\n      const isCatchall = segmentParam.type === 'catchall'\n      const isOptionalCatchall = segmentParam.type === 'optional-catchall'\n\n      if (isCatchall || isOptionalCatchall) {\n        const dynamicParamType = dynamicParamTypes[segmentParam.type]\n        // handle the case where an optional catchall does not have a value,\n        // e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`\n        if (isOptionalCatchall) {\n          return {\n            param: key,\n            value: null,\n            type: dynamicParamType,\n            treeSegment: [key, '', dynamicParamType],\n          }\n        }\n\n        // handle the case where a catchall or optional catchall does not have a value,\n        // e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched\n        value = pagePath\n          .split('/')\n          // remove the first empty string\n          .slice(1)\n          // replace any dynamic params with the actual values\n          .flatMap((pathSegment) => {\n            const param = parseParameter(pathSegment)\n            // if the segment matches a param, return the param value\n            // otherwise, it's a static segment, so just return that\n            return params[param.key] ?? param.key\n          })\n\n        return {\n          param: key,\n          value,\n          type: dynamicParamType,\n          // This value always has to be a string.\n          treeSegment: [key, value.join('/'), dynamicParamType],\n        }\n      }\n    }\n\n    const type = getShortDynamicParamType(segmentParam.type)\n\n    return {\n      param: key,\n      // The value that is passed to user code.\n      value: value,\n      // The value that is rendered in the router tree.\n      treeSegment: [key, Array.isArray(value) ? value.join('/') : value, type],\n      type: type,\n    }\n  }\n}\n\nfunction NonIndex({\n  pagePath,\n  statusCode,\n  isPossibleServerAction,\n}: {\n  pagePath: string\n  statusCode: number | undefined\n  isPossibleServerAction: boolean\n}) {\n  const is404Page = pagePath === '/404'\n  const isInvalidStatusCode = typeof statusCode === 'number' && statusCode > 400\n\n  // Only render noindex for page request, skip for server actions\n  // TODO: is this correct if `isPossibleServerAction` is a false positive?\n  if (!isPossibleServerAction && (is404Page || isInvalidStatusCode)) {\n    return <meta name=\"robots\" content=\"noindex\" />\n  }\n  return null\n}\n\n/**\n * This is used by server actions & client-side navigations to generate RSC data from a client-side request.\n * This function is only called on \"dynamic\" requests (ie, there wasn't already a static response).\n * It uses request headers (namely `Next-Router-State-Tree`) to determine where to start rendering.\n */\nasync function generateDynamicRSCPayload(\n  ctx: AppRenderContext,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n  }\n): Promise<RSCPayload> {\n  // Flight data that is going to be passed to the browser.\n  // Currently a single item array but in the future multiple patches might be combined in a single request.\n\n  // We initialize `flightData` to an empty string because the client router knows how to tolerate\n  // it (treating it as an MPA navigation). The only time this function wouldn't generate flight data\n  // is for server actions, if the server action handler instructs this function to skip it. When the server\n  // action reducer sees a falsy value, it'll simply resolve the action with no data.\n  let flightData: FlightData = ''\n\n  const {\n    componentMod: {\n      tree: loaderTree,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    query,\n    requestId,\n    flightRouterState,\n    workStore,\n    url,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n\n  if (!options?.skipFlight) {\n    const preloadCallbacks: PreloadCallbacks = []\n\n    const {\n      ViewportTree,\n      MetadataTree,\n      getViewportReady,\n      getMetadataReady,\n      StreamingMetadataOutlet,\n    } = createMetadataComponents({\n      tree: loaderTree,\n      parsedQuery: query,\n      metadataContext: createTrackedMetadataContext(\n        url.pathname,\n        ctx.renderOpts,\n        workStore\n      ),\n      getDynamicParamFromSegment,\n      appUsingSizeAdjustment,\n      workStore,\n      MetadataBoundary,\n      ViewportBoundary,\n      serveStreamingMetadata,\n    })\n\n    flightData = (\n      await walkTreeWithFlightRouterState({\n        ctx,\n        loaderTreeToFilter: loaderTree,\n        parentParams: {},\n        flightRouterState,\n        // For flight, render metadata inside leaf page\n        rscHead: (\n          <React.Fragment key={flightDataPathHeadKey}>\n            {/* noindex needs to be blocking */}\n            <NonIndex\n              pagePath={ctx.pagePath}\n              statusCode={ctx.res.statusCode}\n              isPossibleServerAction={ctx.isPossibleServerAction}\n            />\n            {/* Adding requestId as react key to make metadata remount for each render */}\n            <ViewportTree key={getFlightViewportKey(requestId)} />\n            {/* Not add requestId as react key to ensure segment prefetch could result consistently if nothing changed */}\n            <MetadataTree key={getFlightMetadataKey(requestId)} />\n          </React.Fragment>\n        ),\n        injectedCSS: new Set(),\n        injectedJS: new Set(),\n        injectedFontPreloadTags: new Set(),\n        rootLayoutIncluded: false,\n        getViewportReady,\n        getMetadataReady,\n        preloadCallbacks,\n        StreamingMetadataOutlet,\n      })\n    ).map((path) => path.slice(1)) // remove the '' (root) segment\n  }\n\n  // If we have an action result, then this is a server action response.\n  // We can rely on this because `ActionResult` will always be a promise, even if\n  // the result is falsey.\n  if (options?.actionResult) {\n    return {\n      a: options.actionResult,\n      f: flightData,\n      b: ctx.sharedContext.buildId,\n    }\n  }\n\n  // Otherwise, it's a regular RSC response.\n  return {\n    b: ctx.sharedContext.buildId,\n    f: flightData,\n    S: workStore.isStaticGeneration,\n  }\n}\n\nfunction createErrorContext(\n  ctx: AppRenderContext,\n  renderSource: RequestErrorContext['renderSource']\n): RequestErrorContext {\n  return {\n    routerKind: 'App Router',\n    routePath: ctx.pagePath,\n    // TODO: is this correct if `isPossibleServerAction` is a false positive?\n    routeType: ctx.isPossibleServerAction ? 'action' : 'render',\n    renderSource,\n    revalidateReason: getRevalidateReason(ctx.workStore),\n  }\n}\n/**\n * Produces a RenderResult containing the Flight data for the given request. See\n * `generateDynamicRSCPayload` for information on the contents of the render result.\n */\nasync function generateDynamicFlightRenderResult(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  requestStore: RequestStore,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n    componentTree?: CacheNodeSeedData\n    preloadCallbacks?: PreloadCallbacks\n    temporaryReferences?: WeakMap<any, string>\n  }\n): Promise<RenderResult> {\n  const renderOpts = ctx.renderOpts\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    !!renderOpts.dev,\n    onFlightDataRenderError\n  )\n\n  const RSCPayload: RSCPayload & {\n    /** Only available during dynamicIO development builds. Used for logging errors. */\n    _validation?: Promise<React.ReactNode>\n  } = await workUnitAsyncStorage.run(\n    requestStore,\n    generateDynamicRSCPayload,\n    ctx,\n    options\n  )\n\n  if (\n    // We only want this behavior when running `next dev`\n    renderOpts.dev &&\n    // We only want this behavior when we have React's dev builds available\n    process.env.NODE_ENV === 'development' &&\n    // We only have a Prerender environment for projects opted into dynamicIO\n    renderOpts.experimental.dynamicIO\n  ) {\n    const [resolveValidation, validationOutlet] = createValidationOutlet()\n    RSCPayload._validation = validationOutlet\n\n    spawnDynamicValidationInDev(\n      resolveValidation,\n      ctx.componentMod.tree,\n      ctx,\n      false,\n      ctx.clientReferenceManifest,\n      ctx.workStore.route,\n      requestStore\n    )\n  }\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  const flightReadableStream = workUnitAsyncStorage.run(\n    requestStore,\n    ctx.componentMod.renderToReadableStream,\n    RSCPayload,\n    ctx.clientReferenceManifest.clientModules,\n    {\n      onError,\n      temporaryReferences: options?.temporaryReferences,\n    }\n  )\n\n  return new FlightRenderResult(flightReadableStream, {\n    fetchMetrics: ctx.workStore.fetchMetrics,\n  })\n}\n\n/**\n * Performs a \"warmup\" render of the RSC payload for a given route. This function is called by the server\n * prior to an actual render request in Dev mode only. It's purpose is to fill caches so the actual render\n * can accurately log activity in the right render context (Prerender vs Render).\n *\n * At the moment this implementation is mostly a fork of generateDynamicFlightRenderResult\n */\nasync function warmupDevRender(\n  req: BaseNextRequest,\n  ctx: AppRenderContext\n): Promise<RenderResult> {\n  const {\n    clientReferenceManifest,\n    componentMod,\n    getDynamicParamFromSegment,\n    implicitTags,\n    renderOpts,\n    workStore,\n  } = ctx\n\n  if (!renderOpts.dev) {\n    throw new InvariantError(\n      'generateDynamicFlightRenderResult should never be called in `next start` mode.'\n    )\n  }\n\n  const rootParams = getRootParams(\n    componentMod.tree,\n    getDynamicParamFromSegment\n  )\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    true,\n    onFlightDataRenderError\n  )\n\n  // We're doing a dev warmup, so we should create a new resume data cache so\n  // we can fill it.\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n  const renderController = new AbortController()\n  const prerenderController = new AbortController()\n  const cacheSignal = new CacheSignal()\n\n  const prerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: renderController.signal,\n    controller: prerenderController,\n    cacheSignal,\n    dynamicTracking: null,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n    hmrRefreshHash: req.cookies[NEXT_HMR_REFRESH_HASH_COOKIE],\n  }\n\n  const rscPayload = await workUnitAsyncStorage.run(\n    prerenderStore,\n    generateDynamicRSCPayload,\n    ctx\n  )\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  workUnitAsyncStorage.run(\n    prerenderStore,\n    componentMod.renderToReadableStream,\n    rscPayload,\n    clientReferenceManifest.clientModules,\n    {\n      onError,\n      signal: renderController.signal,\n    }\n  )\n\n  // Wait for all caches to be finished filling\n  await cacheSignal.cacheReady()\n  // We unset the cache so any late over-run renders aren't able to write into this cache\n  prerenderStore.prerenderResumeDataCache = null\n  // Abort the render\n  renderController.abort()\n\n  // We don't really want to return a result here but the stack of functions\n  // that calls into renderToHTML... expects a result. We should refactor this to\n  // lift the warmup pathway outside of renderToHTML... but for now this suffices\n  return new FlightRenderResult('', {\n    fetchMetrics: workStore.fetchMetrics,\n    devRenderResumeDataCache: createRenderResumeDataCache(\n      prerenderResumeDataCache\n    ),\n  })\n}\n\n/**\n * Crawlers will inadvertently think the canonicalUrl in the RSC payload should be crawled\n * when our intention is to just seed the router state with the current URL.\n * This function splits up the pathname so that we can later join it on\n * when we're ready to consume the path.\n */\nfunction prepareInitialCanonicalUrl(url: RequestStore['url']) {\n  return (url.pathname + url.search).split('/')\n}\n\n// This is the data necessary to render <AppRouter /> when no SSR errors are encountered\nasync function getRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  is404: boolean\n): Promise<InitialRSCPayload & { P: React.ReactNode }> {\n  const injectedCSS = new Set<string>()\n  const injectedJS = new Set<string>()\n  const injectedFontPreloadTags = new Set<string>()\n  let missingSlots: Set<string> | undefined\n\n  // We only track missing parallel slots in development\n  if (process.env.NODE_ENV === 'development') {\n    missingSlots = new Set<string>()\n  }\n\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      GlobalError,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    url,\n    workStore,\n  } = ctx\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n\n  const {\n    ViewportTree,\n    MetadataTree,\n    getViewportReady,\n    getMetadataReady,\n    StreamingMetadataOutlet,\n  } = createMetadataComponents({\n    tree,\n    errorType: is404 ? 'not-found' : undefined,\n    parsedQuery: query,\n    metadataContext: createTrackedMetadataContext(\n      url.pathname,\n      ctx.renderOpts,\n      workStore\n    ),\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    workStore,\n    MetadataBoundary,\n    ViewportBoundary,\n    serveStreamingMetadata,\n  })\n\n  const preloadCallbacks: PreloadCallbacks = []\n\n  const seedData = await createComponentTree({\n    ctx,\n    loaderTree: tree,\n    parentParams: {},\n    injectedCSS,\n    injectedJS,\n    injectedFontPreloadTags,\n    rootLayoutIncluded: false,\n    getViewportReady,\n    getMetadataReady,\n    missingSlots,\n    preloadCallbacks,\n    authInterrupts: ctx.renderOpts.experimental.authInterrupts,\n    StreamingMetadataOutlet,\n  })\n\n  // When the `vary` response header is present with `Next-URL`, that means there's a chance\n  // it could respond differently if there's an interception route. We provide this information\n  // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.\n  const varyHeader = ctx.res.getHeader('vary')\n  const couldBeIntercepted =\n    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex\n        pagePath={ctx.pagePath}\n        statusCode={ctx.res.statusCode}\n        isPossibleServerAction={ctx.isPossibleServerAction}\n      />\n      <ViewportTree key={getFlightViewportKey(ctx.requestId)} />\n      {/* Not add requestId as react key to ensure segment prefetch could result consistently if nothing changed */}\n      <MetadataTree />\n    </React.Fragment>\n  )\n\n  const globalErrorStyles = await getGlobalErrorStyles(tree, ctx)\n\n  // Assume the head we're rendering contains only partial data if PPR is\n  // enabled and this is a statically generated response. This is used by the\n  // client Segment Cache after a prefetch to determine if it can skip the\n  // second request to fill in the dynamic data.\n  //\n  // See similar comment in create-component-tree.tsx for more context.\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    // See the comment above the `Preloads` component (below) for why this is part of the payload\n    P: <Preloads preloadCallbacks={preloadCallbacks} />,\n    b: ctx.sharedContext.buildId,\n    p: ctx.assetPrefix,\n    c: prepareInitialCanonicalUrl(url),\n    i: !!couldBeIntercepted,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    m: missingSlots,\n    G: [GlobalError, globalErrorStyles],\n    s: typeof ctx.renderOpts.postponed === 'string',\n    S: workStore.isStaticGeneration,\n  }\n}\n\n/**\n * Preload calls (such as `ReactDOM.preloadStyle` and `ReactDOM.preloadFont`) need to be called during rendering\n * in order to create the appropriate preload tags in the DOM, otherwise they're a no-op. Since we invoke\n * renderToReadableStream with a function that returns component props rather than a component itself, we use\n * this component to \"render  \" the preload calls.\n */\nfunction Preloads({ preloadCallbacks }: { preloadCallbacks: Function[] }) {\n  preloadCallbacks.forEach((preloadFn) => preloadFn())\n  return null\n}\n\n// This is the data necessary to render <AppRouter /> when an error state is triggered\nasync function getErrorRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  ssrError: unknown,\n  errorType: MetadataErrorType | 'redirect' | undefined\n) {\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      GlobalError,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    url,\n    requestId,\n    workStore,\n  } = ctx\n\n  const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n  const { MetadataTree, ViewportTree } = createMetadataComponents({\n    tree,\n    parsedQuery: query,\n    // We create an untracked metadata context here because we can't postpone\n    // again during the error render.\n    metadataContext: createMetadataContext(url.pathname, ctx.renderOpts),\n    errorType,\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    workStore,\n    MetadataBoundary,\n    ViewportBoundary,\n    serveStreamingMetadata: serveStreamingMetadata,\n  })\n\n  // {/* Adding requestId as react key to make metadata remount for each render */}\n  const metadata = <MetadataTree key={getFlightMetadataKey(requestId)} />\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex\n        pagePath={ctx.pagePath}\n        statusCode={ctx.res.statusCode}\n        isPossibleServerAction={ctx.isPossibleServerAction}\n      />\n      {/* Adding requestId as react key to make metadata remount for each render */}\n      <ViewportTree key={getFlightViewportKey(requestId)} />\n      {process.env.NODE_ENV === 'development' && (\n        <meta name=\"next-error\" content=\"not-found\" />\n      )}\n      {metadata}\n    </React.Fragment>\n  )\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  let err: Error | undefined = undefined\n  if (ssrError) {\n    err = isError(ssrError) ? ssrError : new Error(ssrError + '')\n  }\n\n  // For metadata notFound error there's no global not found boundary on top\n  // so we create a not found page with AppRouter\n  const seedData: CacheNodeSeedData = [\n    initialTree[0],\n    <html id=\"__next_error__\">\n      <head>{metadata}</head>\n      <body>\n        {process.env.NODE_ENV !== 'production' && err ? (\n          <template\n            data-next-error-message={err.message}\n            data-next-error-digest={'digest' in err ? err.digest : ''}\n            data-next-error-stack={err.stack}\n          />\n        ) : null}\n      </body>\n    </html>,\n    {},\n    null,\n    false,\n  ]\n\n  const globalErrorStyles = await getGlobalErrorStyles(tree, ctx)\n\n  const isPossiblyPartialHead =\n    workStore.isStaticGeneration &&\n    ctx.renderOpts.experimental.isRoutePPREnabled === true\n\n  return {\n    b: ctx.sharedContext.buildId,\n    p: ctx.assetPrefix,\n    c: prepareInitialCanonicalUrl(url),\n    m: undefined,\n    i: false,\n    f: [\n      [\n        initialTree,\n        seedData,\n        initialHead,\n        isPossiblyPartialHead,\n      ] as FlightDataPath,\n    ],\n    G: [GlobalError, globalErrorStyles],\n    s: typeof ctx.renderOpts.postponed === 'string',\n    S: workStore.isStaticGeneration,\n  } satisfies InitialRSCPayload\n}\n\n// This component must run in an SSR context. It will render the RSC root component\nfunction App<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  ServerInsertedHTMLProvider,\n  ServerInsertedMetadataProvider,\n  gracefullyDegrade,\n  nonce,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  ServerInsertedHTMLProvider: React.ComponentType<{ children: JSX.Element }>\n  ServerInsertedMetadataProvider: React.ComponentType<{ children: JSX.Element }>\n  gracefullyDegrade: boolean\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    // This is not used during hydration, so we don't have to pass a\n    // real timestamp.\n    navigatedAt: -1,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialParallelRoutes: new Map(),\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n    prerendered: response.S,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState, null)\n\n  const { HeadManagerContext } =\n    require('../../shared/lib/head-manager-context.shared-runtime') as typeof import('../../shared/lib/head-manager-context.shared-runtime')\n\n  return (\n    <HeadManagerContext.Provider\n      value={{\n        appDir: true,\n        nonce,\n      }}\n    >\n      <ServerInsertedMetadataProvider>\n        <ServerInsertedHTMLProvider>\n          <AppRouter\n            actionQueue={actionQueue}\n            globalErrorComponentAndStyles={response.G}\n            assetPrefix={response.p}\n            gracefullyDegrade={gracefullyDegrade}\n          />\n        </ServerInsertedHTMLProvider>\n      </ServerInsertedMetadataProvider>\n    </HeadManagerContext.Provider>\n  )\n}\n\n// @TODO our error stream should be probably just use the same root component. But it was previously\n// different I don't want to figure out if that is meaningful at this time so just keeping the behavior\n// consistent for now.\nfunction ErrorApp<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  ServerInsertedMetadataProvider,\n  ServerInsertedHTMLProvider,\n  gracefullyDegrade,\n  nonce,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  ServerInsertedMetadataProvider: React.ComponentType<{ children: JSX.Element }>\n  ServerInsertedHTMLProvider: React.ComponentType<{ children: JSX.Element }>\n  gracefullyDegrade: boolean\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    // This is not used during hydration, so we don't have to pass a\n    // real timestamp.\n    navigatedAt: -1,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    initialParallelRoutes: new Map(),\n    // location is not initialized in the SSR render\n    // it's set to window.location during hydration\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n    prerendered: response.S,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState, null)\n\n  return (\n    <ServerInsertedMetadataProvider>\n      <ServerInsertedHTMLProvider>\n        <AppRouter\n          actionQueue={actionQueue}\n          globalErrorComponentAndStyles={response.G}\n          assetPrefix={response.p}\n          gracefullyDegrade={gracefullyDegrade}\n        />\n      </ServerInsertedHTMLProvider>\n    </ServerInsertedMetadataProvider>\n  )\n}\n\n// We use a trick with TS Generics to branch streams with a type so we can\n// consume the parsed value of a Readable Stream if it was constructed with a\n// certain object shape. The generic type is not used directly in the type so it\n// requires a disabling of the eslint rule disallowing unused vars\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type BinaryStreamOf<T> = ReadableStream<Uint8Array>\n\nasync function renderToHTMLOrFlightImpl(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  url: ReturnType<typeof parseRelativeUrl>,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts,\n  workStore: WorkStore,\n  parsedRequestHeaders: ParsedRequestHeaders,\n  requestEndedState: { ended?: boolean },\n  postponedState: PostponedState | null,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  sharedContext: AppSharedContext\n) {\n  const isNotFoundPath = pagePath === '/404'\n  if (isNotFoundPath) {\n    res.statusCode = 404\n  }\n\n  // A unique request timestamp used by development to ensure that it's\n  // consistent and won't change during this request. This is important to\n  // avoid that resources can be deduped by React Float if the same resource is\n  // rendered or preloaded multiple times: `<link href=\"a.css?v={Date.now()}\"/>`.\n  const requestTimestamp = Date.now()\n\n  const {\n    serverActionsManifest,\n    ComponentMod,\n    nextFontManifest,\n    serverActions,\n    assetPrefix = '',\n    enableTainting,\n  } = renderOpts\n\n  // We need to expose the bundled `require` API globally for\n  // react-server-dom-webpack. This is a hack until we find a better way.\n  if (ComponentMod.__next_app__) {\n    const instrumented = wrapClientComponentLoader(ComponentMod)\n    // @ts-ignore\n    globalThis.__next_require__ = instrumented.require\n    // When we are prerendering if there is a cacheSignal for tracking\n    // cache reads we wrap the loadChunk in this tracking. This allows us\n    // to treat chunk loading with similar semantics as cache reads to avoid\n    // async loading chunks from causing a prerender to abort too early.\n    const __next_chunk_load__: typeof instrumented.loadChunk = (...args) => {\n      const loadingChunk = instrumented.loadChunk(...args)\n      trackChunkLoading(loadingChunk)\n      return loadingChunk\n    }\n    // @ts-expect-error\n    globalThis.__next_chunk_load__ = __next_chunk_load__\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    // reset isr status at start of request\n    const { pathname } = new URL(req.url || '/', 'http://n')\n    renderOpts.setIsrStatus?.(pathname, null)\n  }\n\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextRequest(req)\n  ) {\n    req.originalRequest.on('end', () => {\n      requestEndedState.ended = true\n\n      if ('performance' in globalThis) {\n        const metrics = getClientComponentLoaderMetrics({ reset: true })\n        if (metrics) {\n          getTracer()\n            .startSpan(NextNodeServerSpan.clientComponentLoading, {\n              startTime: metrics.clientComponentLoadStart,\n              attributes: {\n                'next.clientComponentLoadCount':\n                  metrics.clientComponentLoadCount,\n                'next.span_type': NextNodeServerSpan.clientComponentLoading,\n              },\n            })\n            .end(\n              metrics.clientComponentLoadStart +\n                metrics.clientComponentLoadTimes\n            )\n        }\n      }\n    })\n  }\n\n  const metadata: AppPageRenderResultMetadata = {}\n\n  const appUsingSizeAdjustment = !!nextFontManifest?.appUsingSizeAdjust\n\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const serverModuleMap = createServerModuleMap({ serverActionsManifest })\n\n  setReferenceManifestsSingleton({\n    page: workStore.page,\n    clientReferenceManifest,\n    serverActionsManifest,\n    serverModuleMap,\n  })\n\n  ComponentMod.patchFetch()\n\n  // Pull out the hooks/references from the component.\n  const { tree: loaderTree, taintObjectReference } = ComponentMod\n\n  if (enableTainting) {\n    taintObjectReference(\n      'Do not pass process.env to Client Components since it will leak sensitive data',\n      process.env\n    )\n  }\n\n  workStore.fetchMetrics = []\n  metadata.fetchMetrics = workStore.fetchMetrics\n\n  // don't modify original query object\n  query = { ...query }\n  stripInternalQueries(query)\n\n  const {\n    flightRouterState,\n    isPrefetchRequest,\n    isRSCRequest,\n    isDevWarmupRequest,\n    isHmrRefresh,\n    nonce,\n  } = parsedRequestHeaders\n\n  /**\n   * The metadata items array created in next-app-loader with all relevant information\n   * that we need to resolve the final metadata.\n   */\n  let requestId: string\n\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    requestId = crypto.randomUUID()\n  } else {\n    requestId = require('next/dist/compiled/nanoid').nanoid()\n  }\n\n  /**\n   * Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {\"slug\": \"vercel\"}.\n   */\n  const params = renderOpts.params ?? {}\n\n  const { isStaticGeneration, fallbackRouteParams } = workStore\n\n  const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(\n    params,\n    pagePath,\n    fallbackRouteParams\n  )\n\n  const isPossibleActionRequest = getIsPossibleServerAction(req)\n\n  const implicitTags = await getImplicitTags(\n    workStore.page,\n    url,\n    fallbackRouteParams\n  )\n\n  const ctx: AppRenderContext = {\n    componentMod: ComponentMod,\n    url,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    getDynamicParamFromSegment,\n    query,\n    isPrefetch: isPrefetchRequest,\n    isPossibleServerAction: isPossibleActionRequest,\n    requestTimestamp,\n    appUsingSizeAdjustment,\n    flightRouterState,\n    requestId,\n    pagePath,\n    clientReferenceManifest,\n    assetPrefix,\n    isNotFoundPath,\n    nonce,\n    res,\n    sharedContext,\n    implicitTags,\n  }\n\n  getTracer().setRootSpanAttribute('next.route', pagePath)\n\n  if (isStaticGeneration) {\n    // We're either building or revalidating. In either case we need to\n    // prerender our page rather than render it.\n    const prerenderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `prerender route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      prerenderToStream\n    )\n\n    const response = await prerenderToStreamWithTracing(\n      req,\n      res,\n      ctx,\n      metadata,\n      workStore,\n      loaderTree\n    )\n\n    // If we're debugging partial prerendering, print all the dynamic API accesses\n    // that occurred during the render.\n    // @TODO move into renderToStream function\n    if (\n      response.dynamicAccess &&\n      accessedDynamicData(response.dynamicAccess) &&\n      renderOpts.isDebugDynamicAccesses\n    ) {\n      warn('The following dynamic usage was detected:')\n      for (const access of formatDynamicAPIAccesses(response.dynamicAccess)) {\n        warn(access)\n      }\n    }\n\n    // If we encountered any unexpected errors during build we fail the\n    // prerendering phase and the build.\n    if (workStore.invalidUsageError) {\n      throw workStore.invalidUsageError\n    }\n    if (response.digestErrorsMap.size) {\n      const buildFailingError = response.digestErrorsMap.values().next().value\n      if (buildFailingError) throw buildFailingError\n    }\n    // Pick first userland SSR error, which is also not a RSC error.\n    if (response.ssrErrors.length) {\n      const buildFailingError = response.ssrErrors.find((err) =>\n        isUserLandError(err)\n      )\n      if (buildFailingError) throw buildFailingError\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n    }\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.pendingRevalidatedTags\n    ) {\n      const pendingPromise = executeRevalidates(workStore).finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url)\n        }\n      })\n\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(pendingPromise)\n      } else {\n        options.waitUntil = pendingPromise\n      }\n    }\n\n    if (response.collectedTags) {\n      metadata.fetchTags = response.collectedTags.join(',')\n    }\n\n    // Let the client router know how long to keep the cached entry around.\n    const staleHeader = String(response.collectedStale)\n    res.setHeader(NEXT_ROUTER_STALE_TIME_HEADER, staleHeader)\n    metadata.headers ??= {}\n    metadata.headers[NEXT_ROUTER_STALE_TIME_HEADER] = staleHeader\n\n    // If force static is specifically set to false, we should not revalidate\n    // the page.\n    if (workStore.forceStatic === false || response.collectedRevalidate === 0) {\n      metadata.cacheControl = { revalidate: 0, expire: undefined }\n    } else {\n      // Copy the cache control value onto the render result metadata.\n      metadata.cacheControl = {\n        revalidate:\n          response.collectedRevalidate >= INFINITE_CACHE\n            ? false\n            : response.collectedRevalidate,\n        expire:\n          response.collectedExpire >= INFINITE_CACHE\n            ? undefined\n            : response.collectedExpire,\n      }\n    }\n\n    // provide bailout info for debugging\n    if (metadata.cacheControl?.revalidate === 0) {\n      metadata.staticBailoutInfo = {\n        description: workStore.dynamicUsageDescription,\n        stack: workStore.dynamicUsageStack,\n      }\n    }\n\n    return new RenderResult(await streamToString(response.stream), options)\n  } else {\n    // We're rendering dynamically\n    const renderResumeDataCache =\n      renderOpts.devRenderResumeDataCache ??\n      postponedState?.renderResumeDataCache\n\n    const rootParams = getRootParams(loaderTree, ctx.getDynamicParamFromSegment)\n    const requestStore = createRequestStoreForRender(\n      req,\n      res,\n      url,\n      rootParams,\n      implicitTags,\n      renderOpts.onUpdateCookies,\n      renderOpts.previewProps,\n      isHmrRefresh,\n      serverComponentsHmrCache,\n      renderResumeDataCache\n    )\n\n    if (\n      process.env.NODE_ENV === 'development' &&\n      renderOpts.setIsrStatus &&\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req) &&\n      !isDevWarmupRequest\n    ) {\n      const setIsrStatus = renderOpts.setIsrStatus\n      req.originalRequest.on('end', () => {\n        if (!requestStore.usedDynamic && !workStore.forceDynamic) {\n          // only node can be ISR so we only need to update the status here\n          const { pathname } = new URL(req.url || '/', 'http://n')\n          setIsrStatus(pathname, true)\n        }\n      })\n    }\n\n    if (isDevWarmupRequest) {\n      return warmupDevRender(req, ctx)\n    } else if (isRSCRequest) {\n      return generateDynamicFlightRenderResult(req, ctx, requestStore)\n    }\n\n    const renderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `render route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      renderToStream\n    )\n\n    let formState: null | any = null\n    if (isPossibleActionRequest) {\n      // For action requests, we handle them differently with a special render result.\n      const actionRequestResult = await handleAction({\n        req,\n        res,\n        ComponentMod,\n        serverModuleMap,\n        generateFlight: generateDynamicFlightRenderResult,\n        workStore,\n        requestStore,\n        serverActions,\n        ctx,\n      })\n\n      if (actionRequestResult) {\n        if (actionRequestResult.type === 'not-found') {\n          const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree)\n          res.statusCode = 404\n          const stream = await renderToStreamWithTracing(\n            requestStore,\n            req,\n            res,\n            ctx,\n            workStore,\n            notFoundLoaderTree,\n            formState,\n            postponedState\n          )\n\n          return new RenderResult(stream, { metadata })\n        } else if (actionRequestResult.type === 'done') {\n          if (actionRequestResult.result) {\n            actionRequestResult.result.assignMetadata(metadata)\n            return actionRequestResult.result\n          } else if (actionRequestResult.formState) {\n            formState = actionRequestResult.formState\n          }\n        }\n      }\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n    }\n\n    const stream = await renderToStreamWithTracing(\n      requestStore,\n      req,\n      res,\n      ctx,\n      workStore,\n      loaderTree,\n      formState,\n      postponedState\n    )\n\n    if (workStore.invalidUsageError) {\n      throw workStore.invalidUsageError\n    }\n\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.pendingRevalidatedTags\n    ) {\n      const pendingPromise = executeRevalidates(workStore).finally(() => {\n        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {\n          console.log('pending revalidates promise finished for:', url)\n        }\n      })\n\n      if (renderOpts.waitUntil) {\n        renderOpts.waitUntil(pendingPromise)\n      } else {\n        options.waitUntil = pendingPromise\n      }\n    }\n\n    // Create the new render result for the response.\n    return new RenderResult(stream, options)\n  }\n}\n\nexport type AppPageRender = (\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  fallbackRouteParams: FallbackRouteParams | null,\n  renderOpts: RenderOpts,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  isDevWarmup: boolean,\n  sharedContext: AppSharedContext\n) => Promise<RenderResult<AppPageRenderResultMetadata>>\n\nexport const renderToHTMLOrFlight: AppPageRender = (\n  req,\n  res,\n  pagePath,\n  query,\n  fallbackRouteParams,\n  renderOpts,\n  serverComponentsHmrCache,\n  isDevWarmup,\n  sharedContext\n) => {\n  if (!req.url) {\n    throw new Error('Invalid URL')\n  }\n\n  const url = parseRelativeUrl(req.url, undefined, false)\n\n  // We read these values from the request object as, in certain cases,\n  // base-server will strip them to opt into different rendering behavior.\n  const parsedRequestHeaders = parseRequestHeaders(req.headers, {\n    isDevWarmup,\n    isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === true,\n    previewModeId: renderOpts.previewProps?.previewModeId,\n  })\n\n  const { isPrefetchRequest, previouslyRevalidatedTags } = parsedRequestHeaders\n\n  const requestEndedState = { ended: false }\n  let postponedState: PostponedState | null = null\n\n  // If provided, the postpone state should be parsed so it can be provided to\n  // React.\n  if (typeof renderOpts.postponed === 'string') {\n    if (fallbackRouteParams) {\n      throw new InvariantError(\n        'postponed state should not be provided when fallback params are provided'\n      )\n    }\n\n    postponedState = parsePostponedState(\n      renderOpts.postponed,\n      renderOpts.params\n    )\n  }\n\n  if (\n    postponedState?.renderResumeDataCache &&\n    renderOpts.devRenderResumeDataCache\n  ) {\n    throw new InvariantError(\n      'postponed state and dev warmup immutable resume data cache should not be provided together'\n    )\n  }\n\n  const workStore = createWorkStore({\n    page: renderOpts.routeModule.definition.page,\n    fallbackRouteParams,\n    renderOpts,\n    requestEndedState,\n    // @TODO move to workUnitStore of type Request\n    isPrefetchRequest,\n    buildId: sharedContext.buildId,\n    previouslyRevalidatedTags,\n  })\n\n  return workAsyncStorage.run(\n    workStore,\n    // The function to run\n    renderToHTMLOrFlightImpl,\n    // all of it's args\n    req,\n    res,\n    url,\n    pagePath,\n    query,\n    renderOpts,\n    workStore,\n    parsedRequestHeaders,\n    requestEndedState,\n    postponedState,\n    serverComponentsHmrCache,\n    sharedContext\n  )\n}\n\nasync function renderToStream(\n  requestStore: RequestStore,\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  workStore: WorkStore,\n  tree: LoaderTree,\n  formState: any,\n  postponedState: PostponedState | null\n): Promise<ReadableStream<Uint8Array>> {\n  const renderOpts = ctx.renderOpts\n  const ComponentMod = renderOpts.ComponentMod\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const { ServerInsertedMetadataProvider, getServerInsertedMetadata } =\n    createServerInsertedMetadata(ctx.nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    renderOpts.experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    renderOpts.buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${ctx.assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n        crossOrigin: renderOpts.crossOrigin,\n        noModule: true,\n        nonce: ctx.nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    renderOpts.buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    ctx.assetPrefix,\n    renderOpts.crossOrigin,\n    renderOpts.subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    ctx.nonce,\n    renderOpts.page\n  )\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  const silenceLogger = false\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerResult: null | ReactServerResult = null\n\n  const setHeader = res.setHeader.bind(res)\n  const appendHeader = res.appendHeader.bind(res)\n\n  try {\n    if (\n      // We only want this behavior when running `next dev`\n      renderOpts.dev &&\n      // We only want this behavior when we have React's dev builds available\n      process.env.NODE_ENV === 'development' &&\n      // Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      // We only have a Prerender environment for projects opted into dynamicIO\n      renderOpts.experimental.dynamicIO\n    ) {\n      // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n      const RSCPayload: InitialRSCPayload & {\n        /** Only available during dynamicIO development builds. Used for logging errors. */\n        _validation?: Promise<React.ReactNode>\n      } = await workUnitAsyncStorage.run(\n        requestStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const [resolveValidation, validationOutlet] = createValidationOutlet()\n      RSCPayload._validation = validationOutlet\n\n      const reactServerStream = await workUnitAsyncStorage.run(\n        requestStore,\n        scheduleInSequentialTasks,\n        () => {\n          requestStore.prerenderPhase = true\n          return ComponentMod.renderToReadableStream(\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n              environmentName: () =>\n                requestStore.prerenderPhase === true ? 'Prerender' : 'Server',\n              filterStackFrame(url: string, _functionName: string): boolean {\n                // The default implementation filters out <anonymous> stack frames\n                // but we want to retain them because current Server Components and\n                // built-in Components in parent stacks don't have source location.\n                return !url.startsWith('node:') && !url.includes('node_modules')\n              },\n            }\n          )\n        },\n        () => {\n          requestStore.prerenderPhase = false\n        }\n      )\n\n      spawnDynamicValidationInDev(\n        resolveValidation,\n        tree,\n        ctx,\n        res.statusCode === 404,\n        clientReferenceManifest,\n        workStore.route,\n        requestStore\n      )\n\n      reactServerResult = new ReactServerResult(reactServerStream)\n    } else {\n      // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n      const RSCPayload = await workUnitAsyncStorage.run(\n        requestStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      reactServerResult = new ReactServerResult(\n        workUnitAsyncStorage.run(\n          requestStore,\n          ComponentMod.renderToReadableStream,\n          RSCPayload,\n          clientReferenceManifest.clientModules,\n          {\n            onError: serverComponentsErrorHandler,\n          }\n        )\n      )\n    }\n\n    // React doesn't start rendering synchronously but we want the RSC render to have a chance to start\n    // before we begin SSR rendering because we want to capture any available preload headers so we tick\n    // one task before continuing\n    await waitAtLeastOneReactRenderTask()\n\n    // If provided, the postpone state should be parsed as JSON so it can be\n    // provided to React.\n    if (typeof renderOpts.postponed === 'string') {\n      if (postponedState?.type === DynamicState.DATA) {\n        // We have a complete HTML Document in the prerender but we need to\n        // still include the new server component render because it was not included\n        // in the static prelude.\n        const inlinedReactServerDataStream = createInlinedDataReadableStream(\n          reactServerResult.tee(),\n          ctx.nonce,\n          formState\n        )\n\n        return chainStreams(\n          inlinedReactServerDataStream,\n          createDocumentClosingStream()\n        )\n      } else if (postponedState) {\n        // We assume we have dynamic HTML requiring a resume render to complete\n        const postponed = getPostponedFromState(postponedState)\n\n        const resume = require('react-dom/server.edge')\n          .resume as (typeof import('react-dom/server.edge'))['resume']\n\n        const htmlStream = await workUnitAsyncStorage.run(\n          requestStore,\n          resume,\n          <App\n            reactServerStream={reactServerResult.tee()}\n            preinitScripts={preinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n            nonce={ctx.nonce}\n            gracefullyDegrade={!!ctx.renderOpts.botType}\n          />,\n          postponed,\n          {\n            onError: htmlRendererErrorHandler,\n            nonce: ctx.nonce,\n          }\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n        return await continueDynamicHTMLResume(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consume(),\n            ctx.nonce,\n            formState\n          ),\n          getServerInsertedHTML,\n          getServerInsertedMetadata,\n        })\n      }\n    }\n\n    // This is a regular dynamic render\n    const renderToReadableStream = require('react-dom/server.edge')\n      .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n\n    const htmlStream = await workUnitAsyncStorage.run(\n      requestStore,\n      renderToReadableStream,\n      <App\n        reactServerStream={reactServerResult.tee()}\n        preinitScripts={preinitScripts}\n        clientReferenceManifest={clientReferenceManifest}\n        ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n        ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n        gracefullyDegrade={!!ctx.renderOpts.botType}\n        nonce={ctx.nonce}\n      />,\n      {\n        onError: htmlRendererErrorHandler,\n        nonce: ctx.nonce,\n        onHeaders: (headers: Headers) => {\n          headers.forEach((value, key) => {\n            appendHeader(key, value)\n          })\n        },\n        maxHeadersLength: renderOpts.reactMaxHeadersLength,\n        bootstrapScripts: [bootstrapScript],\n        formState,\n      }\n    )\n\n    const getServerInsertedHTML = makeGetServerInsertedHTML({\n      polyfills,\n      renderServerInsertedHTML,\n      serverCapturedErrors: allCapturedErrors,\n      basePath: renderOpts.basePath,\n      tracingMetadata: tracingMetadata,\n    })\n    /**\n     * Rules of Static & Dynamic HTML:\n     *\n     *    1.) We must generate static HTML unless the caller explicitly opts\n     *        in to dynamic HTML support.\n     *\n     *    2.) If dynamic HTML support is requested, we must honor that request\n     *        or throw an error. It is the sole responsibility of the caller to\n     *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n     *\n     *   3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n     *       resolve all suspenses and generate a full HTML. e.g. when it's a\n     *       html limited bot requests, we produce the full HTML content.\n     *\n     * These rules help ensure that other existing features like request caching,\n     * coalescing, and ISR continue working as intended.\n     */\n    const generateStaticHTML =\n      renderOpts.supportsDynamicResponse !== true ||\n      !!renderOpts.shouldWaitOnAllReady\n\n    const validateRootLayout = renderOpts.dev\n    return await continueFizzStream(htmlStream, {\n      inlinedDataStream: createInlinedDataReadableStream(\n        reactServerResult.consume(),\n        ctx.nonce,\n        formState\n      ),\n      isStaticGeneration: generateStaticHTML,\n      getServerInsertedHTML,\n      getServerInsertedMetadata,\n      validateRootLayout,\n    })\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${ctx.pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    let errorType: MetadataErrorType | 'redirect' | undefined\n\n    if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n\n      const redirectUrl = addPathPrefix(\n        getURLFromRedirectError(err),\n        renderOpts.basePath\n      )\n\n      // If there were mutable cookies set, we need to set them on the\n      // response.\n      const headers = new Headers()\n      if (appendMutableCookies(headers, requestStore.mutableCookies)) {\n        setHeader('set-cookie', Array.from(headers.values()))\n      }\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      renderOpts.buildManifest,\n      ctx.assetPrefix,\n      renderOpts.crossOrigin,\n      renderOpts.subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      ctx.nonce,\n      '/_not-found/page'\n    )\n\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      requestStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      reactServerErrorsByDigest.has((err as any).digest) ? null : err,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      requestStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    if (reactServerResult === null) {\n      // We errored when we did not have an RSC stream to read from. This is not just a render\n      // error, we need to throw early\n      throw err\n    }\n\n    try {\n      const fizzStream = await workUnitAsyncStorage.run(\n        requestStore,\n        renderToInitialFizzStream,\n        {\n          ReactDOMServer: require('react-dom/server.edge'),\n          element: (\n            <ErrorApp\n              reactServerStream={errorServerStream}\n              ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              preinitScripts={errorPreinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              gracefullyDegrade={!!ctx.renderOpts.botType}\n              nonce={ctx.nonce}\n            />\n          ),\n          streamOptions: {\n            nonce: ctx.nonce,\n            // Include hydration scripts in the HTML\n            bootstrapScripts: [errorBootstrapScript],\n            formState,\n          },\n        }\n      )\n\n      /**\n       * Rules of Static & Dynamic HTML:\n       *\n       *    1.) We must generate static HTML unless the caller explicitly opts\n       *        in to dynamic HTML support.\n       *\n       *    2.) If dynamic HTML support is requested, we must honor that request\n       *        or throw an error. It is the sole responsibility of the caller to\n       *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n       *    3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n       *        resolve all suspenses and generate a full HTML. e.g. when it's a\n       *        html limited bot requests, we produce the full HTML content.\n       *\n       * These rules help ensure that other existing features like request caching,\n       * coalescing, and ISR continue working as intended.\n       */\n      const generateStaticHTML =\n        renderOpts.supportsDynamicResponse !== true ||\n        !!renderOpts.shouldWaitOnAllReady\n      const validateRootLayout = renderOpts.dev\n      return await continueFizzStream(fizzStream, {\n        inlinedDataStream: createInlinedDataReadableStream(\n          // This is intentionally using the readable datastream from the\n          // main render rather than the flight data from the error page\n          // render\n          reactServerResult.consume(),\n          ctx.nonce,\n          formState\n        ),\n        isStaticGeneration: generateStaticHTML,\n        getServerInsertedHTML: makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: [],\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        }),\n        getServerInsertedMetadata,\n        validateRootLayout,\n      })\n    } catch (finalErr: any) {\n      if (\n        process.env.NODE_ENV === 'development' &&\n        isHTTPAccessFallbackError(finalErr)\n      ) {\n        const { bailOnRootNotFound } =\n          require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n        bailOnRootNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nfunction createValidationOutlet() {\n  let resolveValidation: (value: React.ReactNode) => void\n  let outlet = new Promise<React.ReactNode>((resolve) => {\n    resolveValidation = resolve\n  })\n  return [resolveValidation!, outlet] as const\n}\n\nasync function spawnDynamicValidationInDev(\n  resolveValidation: (validatingElement: React.ReactNode) => void,\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  isNotFound: boolean,\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>,\n  route: string,\n  requestStore: RequestStore\n): Promise<void> {\n  const { componentMod: ComponentMod, implicitTags } = ctx\n  const rootParams = getRootParams(\n    ComponentMod.tree,\n    ctx.getDynamicParamFromSegment\n  )\n\n  const hmrRefreshHash = requestStore.cookies.get(\n    NEXT_HMR_REFRESH_HASH_COOKIE\n  )?.value\n\n  // Prerender controller represents the lifetime of the prerender.\n  // It will be aborted when a Task is complete or a synchronously aborting\n  // API is called. Notably during cache-filling renders this does not actually\n  // terminate the render itself which will continue until all caches are filled\n  const initialServerPrerenderController = new AbortController()\n\n  // This controller represents the lifetime of the React render call. Notably\n  // during the cache-filling render it is different from the prerender controller\n  // because we don't want to end the react render until all caches are filled.\n  const initialServerRenderController = new AbortController()\n\n  const cacheSignal = new CacheSignal()\n  const prerenderResumeDataCache = createPrerenderResumeDataCache()\n  const initialServerPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: initialServerRenderController.signal,\n    controller: initialServerPrerenderController,\n    cacheSignal,\n    dynamicTracking: null,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n    hmrRefreshHash,\n  }\n\n  const initialClientController = new AbortController()\n  const initialClientPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: initialClientController.signal,\n    controller: initialClientController,\n    cacheSignal,\n    dynamicTracking: null,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n    hmrRefreshHash,\n  }\n\n  // We're not going to use the result of this render because the only time it could be used\n  // is if it completes in a microtask and that's likely very rare for any non-trivial app\n  const firstAttemptRSCPayload = await workUnitAsyncStorage.run(\n    initialServerPrerenderStore,\n    getRSCPayload,\n    tree,\n    ctx,\n    isNotFound\n  )\n\n  let initialServerStream\n  try {\n    initialServerStream = workUnitAsyncStorage.run(\n      initialServerPrerenderStore,\n      ComponentMod.renderToReadableStream,\n      firstAttemptRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: (err) => {\n          const digest = getDigestForWellKnownError(err)\n\n          if (digest) {\n            return digest\n          }\n\n          if (\n            initialServerPrerenderController.signal.aborted ||\n            initialServerRenderController.signal.aborted\n          ) {\n            // The render aborted before this error was handled which indicates\n            // the error is caused by unfinished components within the render\n            return\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            printDebugThrownValueForProspectiveRender(err, route)\n          }\n        },\n        signal: initialServerRenderController.signal,\n      }\n    )\n  } catch (err: unknown) {\n    if (\n      initialServerPrerenderController.signal.aborted ||\n      initialServerRenderController.signal.aborted\n    ) {\n      // These are expected errors that might error the prerender. we ignore them.\n    } else if (\n      process.env.NEXT_DEBUG_BUILD ||\n      process.env.__NEXT_VERBOSE_LOGGING\n    ) {\n      // We don't normally log these errors because we are going to retry anyway but\n      // it can be useful for debugging Next.js itself to get visibility here when needed\n      printDebugThrownValueForProspectiveRender(err, route)\n    }\n  }\n\n  const nonce = '1'\n  const { ServerInsertedHTMLProvider } = createServerInsertedHTML()\n  const { ServerInsertedMetadataProvider } = createServerInsertedMetadata(nonce)\n\n  if (initialServerStream) {\n    const [warmupStream, renderStream] = initialServerStream.tee()\n    initialServerStream = null\n    // Before we attempt the SSR initial render we need to ensure all client modules\n    // are already loaded.\n    await warmFlightResponse(warmupStream, clientReferenceManifest)\n\n    const prerender = require('react-dom/static.edge')\n      .prerender as (typeof import('react-dom/static.edge'))['prerender']\n    const pendingInitialClientResult = workUnitAsyncStorage.run(\n      initialClientPrerenderStore,\n      prerender,\n      <App\n        reactServerStream={renderStream}\n        preinitScripts={() => {}}\n        clientReferenceManifest={clientReferenceManifest}\n        ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n        ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n        gracefullyDegrade={!!ctx.renderOpts.botType}\n        nonce={nonce}\n      />,\n      {\n        signal: initialClientController.signal,\n        onError: (err) => {\n          const digest = getDigestForWellKnownError(err)\n\n          if (digest) {\n            return digest\n          }\n\n          if (initialClientController.signal.aborted) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, route)\n          }\n        },\n      }\n    )\n    pendingInitialClientResult.catch((err: unknown) => {\n      if (initialClientController.signal.aborted) {\n        // We aborted the render normally and can ignore this error\n      } else {\n        // We're going to retry to so we normally would suppress this error but\n        // when verbose logging is on we print it\n        if (process.env.__NEXT_VERBOSE_LOGGING) {\n          printDebugThrownValueForProspectiveRender(err, route)\n        }\n      }\n    })\n  }\n\n  await cacheSignal.cacheReady()\n  // It is important that we abort the SSR render first to avoid\n  // connection closed errors from having an incomplete RSC stream\n  initialClientController.abort()\n  initialServerRenderController.abort()\n  initialServerPrerenderController.abort()\n\n  // We've now filled caches and triggered any inadvertent sync bailouts\n  // due to lazy module initialization. We can restart our render to capture results\n\n  const finalServerController = new AbortController()\n  const serverDynamicTracking = createDynamicTrackingState(false)\n\n  const finalServerPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: finalServerController.signal,\n    controller: finalServerController,\n    // During the final prerender we don't need to track cache access so we omit the signal\n    cacheSignal: null,\n    dynamicTracking: serverDynamicTracking,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n    hmrRefreshHash,\n  }\n\n  const finalClientController = new AbortController()\n  const clientDynamicTracking = createDynamicTrackingState(false)\n  const dynamicValidation = createDynamicValidationState()\n\n  const finalClientPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    rootParams,\n    implicitTags,\n    renderSignal: finalClientController.signal,\n    controller: finalClientController,\n    // During the final prerender we don't need to track cache access so we omit the signal\n    cacheSignal: null,\n    dynamicTracking: clientDynamicTracking,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    prerenderResumeDataCache,\n    hmrRefreshHash,\n  }\n\n  const finalServerPayload = await workUnitAsyncStorage.run(\n    finalServerPrerenderStore,\n    getRSCPayload,\n    tree,\n    ctx,\n    isNotFound\n  )\n\n  const serverPrerenderStreamResult = await prerenderServerWithPhases(\n    finalServerController.signal,\n    () =>\n      workUnitAsyncStorage.run(\n        finalServerPrerenderStore,\n        ComponentMod.renderToReadableStream,\n        finalServerPayload,\n        clientReferenceManifest.clientModules,\n        {\n          onError: (err) => {\n            if (isUseCacheTimeoutError(err)) {\n              return err.digest\n            }\n\n            if (\n              finalServerController.signal.aborted &&\n              isPrerenderInterruptedError(err)\n            ) {\n              return err.digest\n            }\n\n            return getDigestForWellKnownError(err)\n          },\n          signal: finalServerController.signal,\n        }\n      ),\n    () => {\n      finalServerController.abort()\n    }\n  )\n\n  let rootDidError = false\n  const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream()\n  let preludeIsEmpty = false\n  try {\n    const prerender = require('react-dom/static.edge')\n      .prerender as (typeof import('react-dom/static.edge'))['prerender']\n    const { prelude: unprocessedPrelude } = await prerenderClientWithPhases(\n      () =>\n        workUnitAsyncStorage.run(\n          finalClientPrerenderStore,\n          prerender,\n          <App\n            reactServerStream={serverPhasedStream}\n            preinitScripts={() => {}}\n            clientReferenceManifest={clientReferenceManifest}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n            gracefullyDegrade={!!ctx.renderOpts.botType}\n            nonce={ctx.nonce}\n          />,\n          {\n            signal: finalClientController.signal,\n            onError: (err, errorInfo) => {\n              if (isUseCacheTimeoutError(err)) {\n                dynamicValidation.dynamicErrors.push(err)\n\n                return\n              }\n\n              if (\n                isPrerenderInterruptedError(err) ||\n                finalClientController.signal.aborted\n              ) {\n                if (!rootDidError) {\n                  // If the root errored before we observe this error then it wasn't caused by something dynamic.\n                  // If the root did not error or is erroring because of a sync dynamic API or a prerender interrupt error\n                  // then we are a dynamic route.\n                  requestStore.usedDynamic = true\n                }\n\n                const componentStack = errorInfo.componentStack\n                if (typeof componentStack === 'string') {\n                  trackAllowedDynamicAccess(\n                    route,\n                    componentStack,\n                    dynamicValidation\n                  )\n                }\n                return\n              }\n\n              return getDigestForWellKnownError(err)\n            },\n          }\n        ),\n      () => {\n        finalClientController.abort()\n        serverPhasedStream.assertExhausted()\n      }\n    )\n    preludeIsEmpty = (await processPrelude(unprocessedPrelude)).preludeIsEmpty\n  } catch (err) {\n    rootDidError = true\n    preludeIsEmpty = true\n    if (\n      isPrerenderInterruptedError(err) ||\n      finalClientController.signal.aborted\n    ) {\n      // we don't have a root because the abort errored in the root. We can just ignore this error\n    } else {\n      // If an error is thrown in the root before prerendering is aborted, we\n      // don't want to rethrow it here, otherwise this would lead to a hanging\n      // response and unhandled rejection. We also don't want to log it, because\n      // it's most likely already logged as part of the normal render. So we\n      // just fall through here, to make sure `resolveValidation` is called.\n    }\n  }\n\n  function LogDynamicValidation() {\n    try {\n      // If we've disabled throwing on empty static shell, then we don't need to\n      // track any dynamic access that occurs above the suspense boundary because\n      // we'll do so in the route shell.\n      throwIfDisallowedDynamic(\n        route,\n        preludeIsEmpty,\n        dynamicValidation,\n        serverDynamicTracking,\n        clientDynamicTracking\n      )\n    } catch {}\n    return null\n  }\n\n  resolveValidation(<LogDynamicValidation />)\n}\n\ntype PrerenderToStreamResult = {\n  stream: ReadableStream<Uint8Array>\n  digestErrorsMap: Map<string, DigestedError>\n  ssrErrors: Array<unknown>\n  dynamicAccess?: null | Array<DynamicAccess>\n  collectedRevalidate: number\n  collectedExpire: number\n  collectedStale: number\n  collectedTags: null | string[]\n}\n\n/**\n * Determines whether we should generate static flight data.\n */\nfunction shouldGenerateStaticFlightData(workStore: WorkStore): boolean {\n  const { isStaticGeneration } = workStore\n  if (!isStaticGeneration) return false\n\n  return true\n}\n\nasync function prerenderToStream(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  metadata: AppPageRenderResultMetadata,\n  workStore: WorkStore,\n  tree: LoaderTree\n): Promise<PrerenderToStreamResult> {\n  // When prerendering formState is always null. We still include it\n  // because some shared APIs expect a formState value and this is slightly\n  // more explicit than making it an optional function argument\n  const formState = null\n\n  const {\n    assetPrefix,\n    getDynamicParamFromSegment,\n    implicitTags,\n    nonce,\n    pagePath,\n    renderOpts,\n  } = ctx\n\n  const rootParams = getRootParams(tree, getDynamicParamFromSegment)\n  const ComponentMod = renderOpts.ComponentMod\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n  const fallbackRouteParams = workStore.fallbackRouteParams\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n  const { ServerInsertedMetadataProvider, getServerInsertedMetadata } =\n    createServerInsertedMetadata(nonce)\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    renderOpts.experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    renderOpts.buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n        crossOrigin: renderOpts.crossOrigin,\n        noModule: true,\n        nonce: nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    renderOpts.buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    assetPrefix,\n    renderOpts.crossOrigin,\n    renderOpts.subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    nonce,\n    renderOpts.page\n  )\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  // We don't report errors during prerendering through our instrumentation hooks\n  const silenceLogger = !!renderOpts.experimental.isRoutePPREnabled\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerPrerenderResult:\n    | null\n    | ReactServerPrerenderResult\n    | ServerPrerenderStreamResult = null\n  const setMetadataHeader = (name: string) => {\n    metadata.headers ??= {}\n    metadata.headers[name] = res.getHeader(name)\n  }\n  const setHeader = (name: string, value: string | string[]) => {\n    res.setHeader(name, value)\n    setMetadataHeader(name)\n    return res\n  }\n  const appendHeader = (name: string, value: string | string[]) => {\n    if (Array.isArray(value)) {\n      value.forEach((item) => {\n        res.appendHeader(name, item)\n      })\n    } else {\n      res.appendHeader(name, value)\n    }\n    setMetadataHeader(name)\n  }\n\n  let prerenderStore: PrerenderStore | null = null\n\n  try {\n    if (renderOpts.experimental.dynamicIO) {\n      if (renderOpts.experimental.isRoutePPREnabled) {\n        /**\n         * dynamicIO with PPR\n         *\n         * The general approach is to render the RSC stream first allowing any cache reads to resolve.\n         * Once we have settled all cache reads we restart the render and abort after a single Task.\n         *\n         * Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used\n         * during the initial render because we need to ensure all caches can be filled as part of the initial Task\n         * and a synchronous abort might prevent us from filling all caches.\n         *\n         * Once the render is complete we allow the SSR render to finish and use a combination of the postponed state\n         * and the reactServerIsDynamic value to determine how to treat the resulting render\n         */\n\n        // Prerender controller represents the lifetime of the prerender.\n        // It will be aborted when a Task is complete or a synchronously aborting\n        // API is called. Notably during cache-filling renders this does not actually\n        // terminate the render itself which will continue until all caches are filled\n        const initialServerPrerenderController = new AbortController()\n\n        // This controller represents the lifetime of the React render call. Notably\n        // during the cache-filling render it is different from the prerender controller\n        // because we don't want to end the react render until all caches are filled.\n        const initialServerRenderController = new AbortController()\n\n        // The cacheSignal helps us track whether caches are still filling or we are ready\n        // to cut the render off.\n        const cacheSignal = new CacheSignal()\n\n        // The resume data cache here should use a fresh instance as it's\n        // performing a fresh prerender. If we get to implementing the\n        // prerendering of an already prerendered page, we should use the passed\n        // resume data cache instead.\n        const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n        const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: initialServerRenderController.signal,\n          controller: initialServerPrerenderController,\n          cacheSignal,\n          dynamicTracking: null,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        })\n\n        // We're not going to use the result of this render because the only time it could be used\n        // is if it completes in a microtask and that's likely very rare for any non-trivial app\n        const initialServerPayload = await workUnitAsyncStorage.run(\n          initialServerPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        const pendingInitialServerResult = workUnitAsyncStorage.run(\n          initialServerPrerenderStore,\n          ComponentMod.prerender,\n          initialServerPayload,\n          clientReferenceManifest.clientModules,\n          {\n            onError: (err) => {\n              const digest = getDigestForWellKnownError(err)\n\n              if (digest) {\n                return digest\n              }\n\n              if (initialServerPrerenderController.signal.aborted) {\n                // The render aborted before this error was handled which indicates\n                // the error is caused by unfinished components within the render\n                return\n              } else if (\n                process.env.NEXT_DEBUG_BUILD ||\n                process.env.__NEXT_VERBOSE_LOGGING\n              ) {\n                printDebugThrownValueForProspectiveRender(err, workStore.route)\n              }\n            },\n            // we don't care to track postpones during the prospective render because we need\n            // to always do a final render anyway\n            onPostpone: undefined,\n            // We don't want to stop rendering until the cacheSignal is complete so we pass\n            // a different signal to this render call than is used by dynamic APIs to signify\n            // transitioning out of the prerender environment\n            signal: initialServerRenderController.signal,\n          }\n        )\n\n        await cacheSignal.cacheReady()\n        initialServerRenderController.abort()\n        initialServerPrerenderController.abort()\n\n        let initialServerResult\n        try {\n          initialServerResult = await createReactServerPrerenderResult(\n            pendingInitialServerResult\n          )\n        } catch (err) {\n          if (\n            initialServerRenderController.signal.aborted ||\n            initialServerPrerenderController.signal.aborted\n          ) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n        }\n\n        if (initialServerResult) {\n          // Before we attempt the SSR initial render we need to ensure all client modules\n          // are already loaded.\n          await warmFlightResponse(\n            initialServerResult.asStream(),\n            clientReferenceManifest\n          )\n\n          const initialClientController = new AbortController()\n          const initialClientPrerenderStore: PrerenderStore = {\n            type: 'prerender',\n            phase: 'render',\n            rootParams,\n            implicitTags,\n            renderSignal: initialClientController.signal,\n            controller: initialClientController,\n            cacheSignal: null,\n            dynamicTracking: null,\n            revalidate: INFINITE_CACHE,\n            expire: INFINITE_CACHE,\n            stale: INFINITE_CACHE,\n            tags: [...implicitTags.tags],\n            prerenderResumeDataCache,\n            hmrRefreshHash: undefined,\n          }\n\n          const prerender = require('react-dom/static.edge')\n            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n          await prerenderAndAbortInSequentialTasks(\n            () =>\n              workUnitAsyncStorage.run(\n                initialClientPrerenderStore,\n                prerender,\n                <App\n                  reactServerStream={initialServerResult.asUnclosingStream()}\n                  preinitScripts={preinitScripts}\n                  clientReferenceManifest={clientReferenceManifest}\n                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                  ServerInsertedMetadataProvider={\n                    ServerInsertedMetadataProvider\n                  }\n                  gracefullyDegrade={!!ctx.renderOpts.botType}\n                  nonce={nonce}\n                />,\n                {\n                  signal: initialClientController.signal,\n                  onError: (err) => {\n                    const digest = getDigestForWellKnownError(err)\n\n                    if (digest) {\n                      return digest\n                    }\n\n                    if (initialClientController.signal.aborted) {\n                      // These are expected errors that might error the prerender. we ignore them.\n                    } else if (\n                      process.env.NEXT_DEBUG_BUILD ||\n                      process.env.__NEXT_VERBOSE_LOGGING\n                    ) {\n                      // We don't normally log these errors because we are going to retry anyway but\n                      // it can be useful for debugging Next.js itself to get visibility here when needed\n                      printDebugThrownValueForProspectiveRender(\n                        err,\n                        workStore.route\n                      )\n                    }\n                  },\n                  bootstrapScripts: [bootstrapScript],\n                }\n              ),\n            () => {\n              initialClientController.abort()\n            }\n          ).catch((err) => {\n            if (\n              initialServerRenderController.signal.aborted ||\n              isPrerenderInterruptedError(err)\n            ) {\n              // These are expected errors that might error the prerender. we ignore them.\n            } else if (\n              process.env.NEXT_DEBUG_BUILD ||\n              process.env.__NEXT_VERBOSE_LOGGING\n            ) {\n              // We don't normally log these errors because we are going to retry anyway but\n              // it can be useful for debugging Next.js itself to get visibility here when needed\n              printDebugThrownValueForProspectiveRender(err, workStore.route)\n            }\n          })\n        }\n\n        let serverIsDynamic = false\n        const finalServerController = new AbortController()\n        const serverDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n\n        const finalRenderPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: finalServerController.signal,\n          controller: finalServerController,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          dynamicTracking: serverDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        })\n\n        const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n          finalRenderPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n        let prerenderIsPending = true\n        const reactServerResult = (reactServerPrerenderResult =\n          await createReactServerPrerenderResult(\n            prerenderAndAbortInSequentialTasks(\n              async () => {\n                const prerenderResult = await workUnitAsyncStorage.run(\n                  // The store to scope\n                  finalRenderPrerenderStore,\n                  // The function to run\n                  ComponentMod.prerender,\n                  // ... the arguments for the function to run\n                  finalAttemptRSCPayload,\n                  clientReferenceManifest.clientModules,\n                  {\n                    onError: (err: unknown) => {\n                      return serverComponentsErrorHandler(err)\n                    },\n                    signal: finalServerController.signal,\n                  }\n                )\n                prerenderIsPending = false\n                return prerenderResult\n              },\n              () => {\n                if (finalServerController.signal.aborted) {\n                  // If the server controller is already aborted we must have called something\n                  // that required aborting the prerender synchronously such as with new Date()\n                  serverIsDynamic = true\n                  return\n                }\n\n                if (prerenderIsPending) {\n                  // If prerenderIsPending then we have blocked for longer than a Task and we assume\n                  // there is something unfinished.\n                  serverIsDynamic = true\n                }\n                finalServerController.abort()\n              }\n            )\n          ))\n\n        const clientDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n        const finalClientController = new AbortController()\n        const finalClientPrerenderStore: PrerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: finalClientController.signal,\n          controller: finalClientController,\n          // For HTML Generation we don't need to track cache reads (RSC only)\n          cacheSignal: null,\n          dynamicTracking: clientDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        }\n\n        let clientIsDynamic = false\n        let dynamicValidation = createDynamicValidationState()\n\n        const prerender = require('react-dom/static.edge')\n          .prerender as (typeof import('react-dom/static.edge'))['prerender']\n        let { prelude: unprocessedPrelude, postponed } =\n          await prerenderAndAbortInSequentialTasks(\n            () =>\n              workUnitAsyncStorage.run(\n                finalClientPrerenderStore,\n                prerender,\n                <App\n                  reactServerStream={reactServerResult.asUnclosingStream()}\n                  preinitScripts={preinitScripts}\n                  clientReferenceManifest={clientReferenceManifest}\n                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                  ServerInsertedMetadataProvider={\n                    ServerInsertedMetadataProvider\n                  }\n                  gracefullyDegrade={!!ctx.renderOpts.botType}\n                  nonce={nonce}\n                />,\n                {\n                  signal: finalClientController.signal,\n                  onError: (err: unknown, errorInfo: ErrorInfo) => {\n                    if (\n                      isPrerenderInterruptedError(err) ||\n                      finalClientController.signal.aborted\n                    ) {\n                      clientIsDynamic = true\n\n                      const componentStack: string | undefined = (\n                        errorInfo as any\n                      ).componentStack\n                      if (typeof componentStack === 'string') {\n                        trackAllowedDynamicAccess(\n                          workStore.route,\n                          componentStack,\n                          dynamicValidation\n                        )\n                      }\n                      return\n                    }\n\n                    return htmlRendererErrorHandler(err, errorInfo)\n                  },\n                  onHeaders: (headers: Headers) => {\n                    headers.forEach((value, key) => {\n                      appendHeader(key, value)\n                    })\n                  },\n                  maxHeadersLength: renderOpts.reactMaxHeadersLength,\n                  bootstrapScripts: [bootstrapScript],\n                }\n              ),\n            () => {\n              finalClientController.abort()\n            }\n          )\n\n        const { prelude, preludeIsEmpty } =\n          await processPrelude(unprocessedPrelude)\n\n        // If we've disabled throwing on empty static shell, then we don't need to\n        // track any dynamic access that occurs above the suspense boundary because\n        // we'll do so in the route shell.\n        if (!ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n          throwIfDisallowedDynamic(\n            workStore.route,\n            preludeIsEmpty,\n            dynamicValidation,\n            serverDynamicTracking,\n            clientDynamicTracking\n          )\n        }\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n\n        const flightData = await streamToBuffer(reactServerResult.asStream())\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          finalRenderPrerenderStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n\n        if (serverIsDynamic || clientIsDynamic) {\n          if (postponed != null) {\n            // Dynamic HTML case\n            metadata.postponed = await getDynamicHTMLPostponedState(\n              postponed,\n              fallbackRouteParams,\n              prerenderResumeDataCache\n            )\n          } else {\n            // Dynamic Data case\n            metadata.postponed = await getDynamicDataPostponedState(\n              prerenderResumeDataCache\n            )\n          }\n          reactServerResult.consume()\n          return {\n            digestErrorsMap: reactServerErrorsByDigest,\n            ssrErrors: allCapturedErrors,\n            stream: await continueDynamicPrerender(prelude, {\n              getServerInsertedHTML,\n              getServerInsertedMetadata,\n            }),\n            dynamicAccess: consumeDynamicAccess(\n              serverDynamicTracking,\n              clientDynamicTracking\n            ),\n            // TODO: Should this include the SSR pass?\n            collectedRevalidate: finalRenderPrerenderStore.revalidate,\n            collectedExpire: finalRenderPrerenderStore.expire,\n            collectedStale: finalRenderPrerenderStore.stale,\n            collectedTags: finalRenderPrerenderStore.tags,\n          }\n        } else {\n          // Static case\n          if (workStore.forceDynamic) {\n            throw new StaticGenBailoutError(\n              'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n            )\n          }\n\n          let htmlStream = prelude\n          if (postponed != null) {\n            // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n            // so we can set all the postponed boundaries to client render mode before we store the HTML response\n            const resume = require('react-dom/server.edge')\n              .resume as (typeof import('react-dom/server.edge'))['resume']\n\n            // We don't actually want to render anything so we just pass a stream\n            // that never resolves. The resume call is going to abort immediately anyway\n            const foreverStream = new ReadableStream<Uint8Array>()\n\n            const resumeStream = await resume(\n              <App\n                reactServerStream={foreverStream}\n                preinitScripts={() => {}}\n                clientReferenceManifest={clientReferenceManifest}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n                gracefullyDegrade={!!ctx.renderOpts.botType}\n                nonce={nonce}\n              />,\n              JSON.parse(JSON.stringify(postponed)),\n              {\n                signal: createPostponedAbortSignal('static prerender resume'),\n                onError: htmlRendererErrorHandler,\n                nonce,\n              }\n            )\n\n            // First we write everything from the prerender, then we write everything from the aborted resume render\n            htmlStream = chainStreams(prelude, resumeStream)\n          }\n\n          return {\n            digestErrorsMap: reactServerErrorsByDigest,\n            ssrErrors: allCapturedErrors,\n            stream: await continueStaticPrerender(htmlStream, {\n              inlinedDataStream: createInlinedDataReadableStream(\n                reactServerResult.consumeAsStream(),\n                nonce,\n                formState\n              ),\n              getServerInsertedHTML,\n              getServerInsertedMetadata,\n            }),\n            dynamicAccess: consumeDynamicAccess(\n              serverDynamicTracking,\n              clientDynamicTracking\n            ),\n            // TODO: Should this include the SSR pass?\n            collectedRevalidate: finalRenderPrerenderStore.revalidate,\n            collectedExpire: finalRenderPrerenderStore.expire,\n            collectedStale: finalRenderPrerenderStore.stale,\n            collectedTags: finalRenderPrerenderStore.tags,\n          }\n        }\n      } else {\n        /**\n         * dynamicIO without PPR\n         *\n         * The general approach is to render the RSC tree first allowing for any inflight\n         * caches to resolve. Once we have settled inflight caches we can check and see if any\n         * synchronous dynamic APIs were used. If so we don't need to bother doing anything more\n         * because the page will be dynamic on re-render anyway\n         *\n         * If no sync dynamic APIs were used we then re-render and abort after a single Task.\n         * If the render errors we know that the page has some dynamic IO. This assumes and relies\n         * upon caches reading from a in process memory cache and resolving in a microtask. While this\n         * is true from our own default cache implementation and if you don't exceed our LRU size it\n         * might not be true for custom cache implementations.\n         *\n         * Future implementations can do some different strategies during build like using IPC to\n         * synchronously fill caches during this special rendering mode. For now this heuristic should work\n         */\n\n        const cache = workStore.incrementalCache\n        if (!cache) {\n          throw new Error(\n            'Expected incremental cache to exist. This is a bug in Next.js'\n          )\n        }\n\n        // Prerender controller represents the lifetime of the prerender.\n        // It will be aborted when a Task is complete or a synchronously aborting\n        // API is called. Notably during cache-filling renders this does not actually\n        // terminate the render itself which will continue until all caches are filled\n        const initialServerPrerenderController = new AbortController()\n\n        // This controller represents the lifetime of the React render call. Notably\n        // during the cache-filling render it is different from the prerender controller\n        // because we don't want to end the react render until all caches are filled.\n        const initialServerRenderController = new AbortController()\n\n        const cacheSignal = new CacheSignal()\n        const prerenderResumeDataCache = createPrerenderResumeDataCache()\n\n        const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: initialServerRenderController.signal,\n          controller: initialServerPrerenderController,\n          cacheSignal,\n          dynamicTracking: null,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        })\n\n        const initialClientController = new AbortController()\n        const initialClientPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: initialClientController.signal,\n          controller: initialClientController,\n          cacheSignal,\n          dynamicTracking: null,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        })\n\n        // We're not going to use the result of this render because the only time it could be used\n        // is if it completes in a microtask and that's likely very rare for any non-trivial app\n        const firstAttemptRSCPayload = await workUnitAsyncStorage.run(\n          initialServerPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        let initialServerStream\n        try {\n          initialServerStream = workUnitAsyncStorage.run(\n            initialServerPrerenderStore,\n            ComponentMod.renderToReadableStream,\n            firstAttemptRSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: (err) => {\n                const digest = getDigestForWellKnownError(err)\n\n                if (digest) {\n                  return digest\n                }\n\n                if (\n                  initialServerPrerenderController.signal.aborted ||\n                  initialServerRenderController.signal.aborted\n                ) {\n                  // The render aborted before this error was handled which indicates\n                  // the error is caused by unfinished components within the render\n                  return\n                } else if (\n                  process.env.NEXT_DEBUG_BUILD ||\n                  process.env.__NEXT_VERBOSE_LOGGING\n                ) {\n                  printDebugThrownValueForProspectiveRender(\n                    err,\n                    workStore.route\n                  )\n                }\n              },\n              signal: initialServerRenderController.signal,\n            }\n          )\n        } catch (err: unknown) {\n          if (\n            initialServerPrerenderController.signal.aborted ||\n            initialServerRenderController.signal.aborted\n          ) {\n            // These are expected errors that might error the prerender. we ignore them.\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            // We don't normally log these errors because we are going to retry anyway but\n            // it can be useful for debugging Next.js itself to get visibility here when needed\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n        }\n\n        if (initialServerStream) {\n          const [warmupStream, renderStream] = initialServerStream.tee()\n          initialServerStream = null\n          // Before we attempt the SSR initial render we need to ensure all client modules\n          // are already loaded.\n          await warmFlightResponse(warmupStream, clientReferenceManifest)\n\n          const prerender = require('react-dom/static.edge')\n            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n          const pendingInitialClientResult = workUnitAsyncStorage.run(\n            initialClientPrerenderStore,\n            prerender,\n            <App\n              reactServerStream={renderStream}\n              preinitScripts={preinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n              gracefullyDegrade={!!ctx.renderOpts.botType}\n              nonce={nonce}\n            />,\n            {\n              signal: initialClientController.signal,\n              onError: (err) => {\n                const digest = getDigestForWellKnownError(err)\n\n                if (digest) {\n                  return digest\n                }\n\n                if (initialClientController.signal.aborted) {\n                  // These are expected errors that might error the prerender. we ignore them.\n                } else if (\n                  process.env.NEXT_DEBUG_BUILD ||\n                  process.env.__NEXT_VERBOSE_LOGGING\n                ) {\n                  // We don't normally log these errors because we are going to retry anyway but\n                  // it can be useful for debugging Next.js itself to get visibility here when needed\n                  printDebugThrownValueForProspectiveRender(\n                    err,\n                    workStore.route\n                  )\n                }\n              },\n              bootstrapScripts: [bootstrapScript],\n            }\n          )\n          pendingInitialClientResult.catch((err: unknown) => {\n            if (initialClientController.signal.aborted) {\n              // We aborted the render normally and can ignore this error\n            } else {\n              // We're going to retry to so we normally would suppress this error but\n              // when verbose logging is on we print it\n              if (process.env.__NEXT_VERBOSE_LOGGING) {\n                printDebugThrownValueForProspectiveRender(err, workStore.route)\n              }\n            }\n          })\n        }\n\n        await cacheSignal.cacheReady()\n        // It is important that we abort the SSR render first to avoid\n        // connection closed errors from having an incomplete RSC stream\n        initialClientController.abort()\n        initialServerRenderController.abort()\n        initialServerPrerenderController.abort()\n\n        // We've now filled caches and triggered any inadvertant sync bailouts\n        // due to lazy module initialization. We can restart our render to capture results\n\n        let serverIsDynamic = false\n        const finalServerController = new AbortController()\n        const serverDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n\n        const finalServerPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: finalServerController.signal,\n          controller: finalServerController,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          dynamicTracking: serverDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        })\n\n        let clientIsDynamic = false\n        const finalClientController = new AbortController()\n        const clientDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n        const dynamicValidation = createDynamicValidationState()\n\n        const finalClientPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          rootParams,\n          implicitTags,\n          renderSignal: finalClientController.signal,\n          controller: finalClientController,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          dynamicTracking: clientDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...implicitTags.tags],\n          prerenderResumeDataCache,\n          hmrRefreshHash: undefined,\n        })\n\n        const finalServerPayload = await workUnitAsyncStorage.run(\n          finalServerPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        const serverPrerenderStreamResult = (reactServerPrerenderResult =\n          await prerenderServerWithPhases(\n            finalServerController.signal,\n            () =>\n              workUnitAsyncStorage.run(\n                finalServerPrerenderStore,\n                ComponentMod.renderToReadableStream,\n                finalServerPayload,\n                clientReferenceManifest.clientModules,\n                {\n                  onError: (err: unknown) => {\n                    if (finalServerController.signal.aborted) {\n                      serverIsDynamic = true\n                      if (isPrerenderInterruptedError(err)) {\n                        return err.digest\n                      }\n                      return getDigestForWellKnownError(err)\n                    }\n\n                    return serverComponentsErrorHandler(err)\n                  },\n                  signal: finalServerController.signal,\n                }\n              ),\n            () => {\n              finalServerController.abort()\n            }\n          ))\n\n        let htmlStream, preludeIsEmpty\n        const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream()\n        try {\n          const prerender = require('react-dom/static.edge')\n            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n          const result = await prerenderClientWithPhases(\n            () =>\n              workUnitAsyncStorage.run(\n                finalClientPrerenderStore,\n                prerender,\n                <App\n                  reactServerStream={serverPhasedStream}\n                  preinitScripts={preinitScripts}\n                  clientReferenceManifest={clientReferenceManifest}\n                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                  ServerInsertedMetadataProvider={\n                    ServerInsertedMetadataProvider\n                  }\n                  gracefullyDegrade={!!ctx.renderOpts.botType}\n                  nonce={nonce}\n                />,\n                {\n                  signal: finalClientController.signal,\n                  onError: (err: unknown, errorInfo: ErrorInfo) => {\n                    if (\n                      isPrerenderInterruptedError(err) ||\n                      finalClientController.signal.aborted\n                    ) {\n                      clientIsDynamic = true\n\n                      const componentStack: string | undefined = (\n                        errorInfo as any\n                      ).componentStack\n                      if (typeof componentStack === 'string') {\n                        trackAllowedDynamicAccess(\n                          workStore.route,\n                          componentStack,\n                          dynamicValidation\n                        )\n                      }\n                      return\n                    }\n\n                    return htmlRendererErrorHandler(err, errorInfo)\n                  },\n                  bootstrapScripts: [bootstrapScript],\n                }\n              ),\n            () => {\n              finalClientController.abort()\n              serverPhasedStream.assertExhausted()\n            }\n          )\n          const processed = await processPrelude(result.prelude)\n          htmlStream = processed.prelude\n          preludeIsEmpty = processed.preludeIsEmpty\n        } catch (err) {\n          if (\n            isPrerenderInterruptedError(err) ||\n            finalClientController.signal.aborted\n          ) {\n            preludeIsEmpty = true\n          } else {\n            // This error is something else and should bubble up\n            throw err\n          }\n        }\n\n        // If we've disabled throwing on empty static shell, then we don't need to\n        // track any dynamic access that occurs above the suspense boundary because\n        // we'll do so in the route shell.\n        if (!ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n          // We don't have a shell because the root errored when we aborted.\n          throwIfDisallowedDynamic(\n            workStore.route,\n            preludeIsEmpty,\n            dynamicValidation,\n            serverDynamicTracking,\n            clientDynamicTracking\n          )\n        }\n\n        if (serverIsDynamic || clientIsDynamic) {\n          const dynamicReason = serverIsDynamic\n            ? getFirstDynamicReason(serverDynamicTracking)\n            : getFirstDynamicReason(clientDynamicTracking)\n          if (dynamicReason) {\n            throw new DynamicServerError(\n              `Route \"${workStore.route}\" couldn't be rendered statically because it used \\`${dynamicReason}\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-data`\n            )\n          } else {\n            throw new DynamicServerError(\n              `Route \"${workStore.route}\" couldn't be rendered statically it accessed data without explicitly caching it. See more info here: https://nextjs.org/docs/messages/next-prerender-data`\n            )\n          }\n        }\n\n        const flightData = await streamToBuffer(\n          serverPrerenderStreamResult.asStream()\n        )\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          finalClientPrerenderStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n        const validateRootLayout = renderOpts.dev\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueFizzStream(htmlStream!, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              serverPrerenderStreamResult.asStream(),\n              nonce,\n              formState\n            ),\n            isStaticGeneration: true,\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n            validateRootLayout,\n          }),\n          dynamicAccess: consumeDynamicAccess(\n            serverDynamicTracking,\n            clientDynamicTracking\n          ),\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: finalServerPrerenderStore.revalidate,\n          collectedExpire: finalServerPrerenderStore.expire,\n          collectedStale: finalServerPrerenderStore.stale,\n          collectedTags: finalServerPrerenderStore.tags,\n        }\n      }\n    } else if (renderOpts.experimental.isRoutePPREnabled) {\n      // We're statically generating with PPR and need to do dynamic tracking\n      let dynamicTracking = createDynamicTrackingState(\n        renderOpts.isDebugDynamicAccesses\n      )\n\n      const prerenderResumeDataCache = createPrerenderResumeDataCache()\n      const reactServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n      })\n      const RSCPayload = await workUnitAsyncStorage.run(\n        reactServerPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            reactServerPrerenderStore,\n            ComponentMod.renderToReadableStream,\n            // ... the arguments for the function to run\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const ssrPrerenderStore: PrerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n        prerenderResumeDataCache,\n      }\n      const prerender = require('react-dom/static.edge')\n        .prerender as (typeof import('react-dom/static.edge'))['prerender']\n      const { prelude, postponed } = await workUnitAsyncStorage.run(\n        ssrPrerenderStore,\n        prerender,\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          preinitScripts={preinitScripts}\n          clientReferenceManifest={clientReferenceManifest}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n          gracefullyDegrade={!!ctx.renderOpts.botType}\n          nonce={nonce}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          onHeaders: (headers: Headers) => {\n            headers.forEach((value, key) => {\n              appendHeader(key, value)\n            })\n          },\n          maxHeadersLength: renderOpts.reactMaxHeadersLength,\n          bootstrapScripts: [bootstrapScript],\n        }\n      )\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      // After awaiting here we've waited for the entire RSC render to complete. Crucially this means\n      // that when we detect whether we've used dynamic APIs below we know we'll have picked up even\n      // parts of the React Server render that might not be used in the SSR render.\n      const flightData = await streamToBuffer(reactServerResult.asStream())\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          ssrPrerenderStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n      }\n\n      /**\n       * When prerendering there are three outcomes to consider\n       *\n       *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)\n       *                      We will need to resume this result when requests are handled and we don't include\n       *                      any server inserted HTML or inlined flight data in the static HTML\n       *\n       *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not\n       *                      resume this render when requests are handled but we will generate new inlined\n       *                      flight data since it is dynamic and differences may end up reconciling on the client\n       *\n       *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode\n       *                      all server inserted HTML and flight data\n       */\n      // First we check if we have any dynamic holes in our HTML prerender\n      if (accessedDynamicData(dynamicTracking.dynamicAccesses)) {\n        if (postponed != null) {\n          // Dynamic HTML case.\n          metadata.postponed = await getDynamicHTMLPostponedState(\n            postponed,\n            fallbackRouteParams,\n            prerenderResumeDataCache\n          )\n        } else {\n          // Dynamic Data case.\n          metadata.postponed = await getDynamicDataPostponedState(\n            prerenderResumeDataCache\n          )\n        }\n        // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n        // server inserted html in the static response because the html that is part of the prerender may depend on it\n        // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n        // require the same set so we unify the code path here\n        reactServerResult.consume()\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: reactServerPrerenderStore.stale,\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n        // Rendering the fallback case.\n        metadata.postponed = await getDynamicDataPostponedState(\n          prerenderResumeDataCache\n        )\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: reactServerPrerenderStore.stale,\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else {\n        // Static case\n        // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response\n        if (workStore.forceDynamic) {\n          throw new StaticGenBailoutError(\n            'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n          )\n        }\n\n        let htmlStream = prelude\n        if (postponed != null) {\n          // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n          // so we can set all the postponed boundaries to client render mode before we store the HTML response\n          const resume = require('react-dom/server.edge')\n            .resume as (typeof import('react-dom/server.edge'))['resume']\n\n          // We don't actually want to render anything so we just pass a stream\n          // that never resolves. The resume call is going to abort immediately anyway\n          const foreverStream = new ReadableStream<Uint8Array>()\n\n          const resumeStream = await resume(\n            <App\n              reactServerStream={foreverStream}\n              preinitScripts={() => {}}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n              gracefullyDegrade={!!ctx.renderOpts.botType}\n              nonce={nonce}\n            />,\n            JSON.parse(JSON.stringify(postponed)),\n            {\n              signal: createPostponedAbortSignal('static prerender resume'),\n              onError: htmlRendererErrorHandler,\n              nonce,\n            }\n          )\n\n          // First we write everything from the prerender, then we write everything from the aborted resume render\n          htmlStream = chainStreams(prelude, resumeStream)\n        }\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueStaticPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n            getServerInsertedMetadata,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: reactServerPrerenderStore.stale,\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      }\n    } else {\n      const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-legacy',\n        phase: 'render',\n        rootParams,\n        implicitTags,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...implicitTags.tags],\n      })\n      // This is a regular static generation. We don't do dynamic tracking because we rely on\n      // the old-school dynamic error handling to bail out of static generation\n      const RSCPayload = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            prerenderLegacyStore,\n            ComponentMod.renderToReadableStream,\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const renderToReadableStream = require('react-dom/server.edge')\n        .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n\n      const htmlStream = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        renderToReadableStream,\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          preinitScripts={preinitScripts}\n          clientReferenceManifest={clientReferenceManifest}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n          gracefullyDegrade={!!ctx.renderOpts.botType}\n          nonce={nonce}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          nonce,\n          bootstrapScripts: [bootstrapScript],\n        }\n      )\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(reactServerResult.asStream())\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n      }\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n      return {\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consumeAsStream(),\n            nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          getServerInsertedHTML,\n          getServerInsertedMetadata,\n        }),\n        // TODO: Should this include the SSR pass?\n        collectedRevalidate: prerenderLegacyStore.revalidate,\n        collectedExpire: prerenderLegacyStore.expire,\n        collectedStale: prerenderLegacyStore.stale,\n        collectedTags: prerenderLegacyStore.tags,\n      }\n    }\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If this is a static generation error, we need to throw it so that it\n    // can be handled by the caller if we're in static generation mode.\n    if (isDynamicServerError(err)) {\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    // If we errored when we did not have an RSC stream to read from. This is\n    // not just a render error, we need to throw early.\n    if (reactServerPrerenderResult === null) {\n      throw err\n    }\n\n    let errorType: MetadataErrorType | 'redirect' | undefined\n\n    if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n      errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n\n      const redirectUrl = addPathPrefix(\n        getURLFromRedirectError(err),\n        renderOpts.basePath\n      )\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      renderOpts.buildManifest,\n      assetPrefix,\n      renderOpts.crossOrigin,\n      renderOpts.subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      nonce,\n      '/_not-found/page'\n    )\n\n    const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n      type: 'prerender-legacy',\n      phase: 'render',\n      rootParams,\n      implicitTags: implicitTags,\n      revalidate:\n        typeof prerenderStore?.revalidate !== 'undefined'\n          ? prerenderStore.revalidate\n          : INFINITE_CACHE,\n      expire:\n        typeof prerenderStore?.expire !== 'undefined'\n          ? prerenderStore.expire\n          : INFINITE_CACHE,\n      stale:\n        typeof prerenderStore?.stale !== 'undefined'\n          ? prerenderStore.stale\n          : INFINITE_CACHE,\n      tags: [...(prerenderStore?.tags || implicitTags.tags)],\n    })\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      reactServerErrorsByDigest.has((err as any).digest) ? undefined : err,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    try {\n      const fizzStream = await renderToInitialFizzStream({\n        ReactDOMServer: require('react-dom/server.edge'),\n        element: (\n          <ErrorApp\n            reactServerStream={errorServerStream}\n            ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            preinitScripts={errorPreinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            gracefullyDegrade={!!ctx.renderOpts.botType}\n            nonce={nonce}\n          />\n        ),\n        streamOptions: {\n          nonce,\n          // Include hydration scripts in the HTML\n          bootstrapScripts: [errorBootstrapScript],\n          formState,\n        },\n      })\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        const flightData = await streamToBuffer(\n          reactServerPrerenderResult.asStream()\n        )\n        metadata.flightData = flightData\n        metadata.segmentData = await collectSegmentData(\n          flightData,\n          prerenderLegacyStore,\n          ComponentMod,\n          renderOpts,\n          fallbackRouteParams\n        )\n      }\n\n      const validateRootLayout = renderOpts.dev\n\n      // This is intentionally using the readable datastream from the main\n      // render rather than the flight data from the error page render\n      const flightStream =\n        reactServerPrerenderResult instanceof ServerPrerenderStreamResult\n          ? reactServerPrerenderResult.asStream()\n          : reactServerPrerenderResult.consumeAsStream()\n\n      return {\n        // Returning the error that was thrown so it can be used to handle\n        // the response in the caller.\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(fizzStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            flightStream,\n            nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          getServerInsertedHTML: makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: [],\n            basePath: renderOpts.basePath,\n            tracingMetadata: tracingMetadata,\n          }),\n          getServerInsertedMetadata,\n          validateRootLayout,\n        }),\n        dynamicAccess: null,\n        collectedRevalidate:\n          prerenderStore !== null ? prerenderStore.revalidate : INFINITE_CACHE,\n        collectedExpire:\n          prerenderStore !== null ? prerenderStore.expire : INFINITE_CACHE,\n        collectedStale:\n          prerenderStore !== null ? prerenderStore.stale : INFINITE_CACHE,\n        collectedTags: prerenderStore !== null ? prerenderStore.tags : null,\n      }\n    } catch (finalErr: any) {\n      if (\n        process.env.NODE_ENV === 'development' &&\n        isHTTPAccessFallbackError(finalErr)\n      ) {\n        const { bailOnRootNotFound } =\n          require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n        bailOnRootNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nconst loadingChunks: Set<Promise<unknown>> = new Set()\nconst chunkListeners: Array<(x?: unknown) => void> = []\n\nfunction trackChunkLoading(load: Promise<unknown>) {\n  loadingChunks.add(load)\n  load.finally(() => {\n    if (loadingChunks.has(load)) {\n      loadingChunks.delete(load)\n      if (loadingChunks.size === 0) {\n        // We are not currently loading any chunks. We can notify all listeners\n        for (let i = 0; i < chunkListeners.length; i++) {\n          chunkListeners[i]()\n        }\n        chunkListeners.length = 0\n      }\n    }\n  })\n}\n\nexport async function warmFlightResponse(\n  flightStream: ReadableStream<Uint8Array>,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n) {\n  const { createFromReadableStream } =\n    // eslint-disable-next-line import/no-extraneous-dependencies\n    require('react-server-dom-webpack/client.edge') as typeof import('react-server-dom-webpack/client.edge')\n\n  try {\n    createFromReadableStream(flightStream, {\n      serverConsumerManifest: {\n        moduleLoading: clientReferenceManifest.moduleLoading,\n        moduleMap: clientReferenceManifest.ssrModuleMapping,\n        serverModuleMap: null,\n      },\n    })\n  } catch {\n    // We don't want to handle errors here but we don't want it to\n    // interrupt the outer flow. We simply ignore it here and expect\n    // it will bubble up during a render\n  }\n\n  // We'll wait at least one task and then if no chunks have started to load\n  // we'll we can infer that there are none to load from this flight response\n  trackChunkLoading(waitAtLeastOneReactRenderTask())\n  return new Promise((r) => {\n    chunkListeners.push(r)\n  })\n}\n\nconst getGlobalErrorStyles = async (\n  tree: LoaderTree,\n  ctx: AppRenderContext\n): Promise<React.ReactNode | undefined> => {\n  const {\n    modules: { 'global-error': globalErrorModule },\n  } = parseLoaderTree(tree)\n\n  let globalErrorStyles\n  if (globalErrorModule) {\n    const [, styles] = await createComponentStylesAndScripts({\n      ctx,\n      filePath: globalErrorModule[1],\n      getComponent: globalErrorModule[0],\n      injectedCSS: new Set(),\n      injectedJS: new Set(),\n    })\n    globalErrorStyles = styles\n  }\n\n  return globalErrorStyles\n}\n\nasync function collectSegmentData(\n  fullPageDataBuffer: Buffer,\n  prerenderStore: PrerenderStore,\n  ComponentMod: AppPageModule,\n  renderOpts: RenderOpts,\n  fallbackRouteParams: FallbackRouteParams | null\n): Promise<Map<string, Buffer> | undefined> {\n  // Per-segment prefetch data\n  //\n  // All of the segments for a page are generated simultaneously, including\n  // during revalidations. This is to ensure consistency, because it's\n  // possible for a mismatch between a layout and page segment can cause the\n  // client to error during rendering. We want to preserve the ability of the\n  // client to recover from such a mismatch by re-requesting all the segments\n  // to get a consistent view of the page.\n  //\n  // For performance, we reuse the Flight output that was created when\n  // generating the initial page HTML. The Flight stream for the whole page is\n  // decomposed into a separate stream per segment.\n\n  const clientReferenceManifest = renderOpts.clientReferenceManifest\n  if (\n    !clientReferenceManifest ||\n    // Do not generate per-segment data unless the experimental Segment Cache\n    // flag is enabled.\n    //\n    // We also skip generating segment data if flag is set to \"client-only\",\n    // rather than true. (The \"client-only\" option only affects the behavior of\n    // the client-side implementation; per-segment prefetches are intentionally\n    // disabled in that configuration).\n    renderOpts.experimental.clientSegmentCache !== true\n  ) {\n    return\n  }\n\n  // Manifest passed to the Flight client for reading the full-page Flight\n  // stream. Based off similar code in use-cache-wrapper.ts.\n  const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n  const serverConsumerManifest = {\n    // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n    // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n    // which themselves will handle the preloading.\n    moduleLoading: null,\n    moduleMap: isEdgeRuntime\n      ? clientReferenceManifest.edgeRscModuleMapping\n      : clientReferenceManifest.rscModuleMapping,\n    serverModuleMap: null,\n  }\n\n  // When dynamicIO is enabled, missing data is encoded to an infinitely hanging\n  // promise, the absence of which we use to determine if a segment is fully\n  // static or partially static. However, when dynamicIO is not enabled, this\n  // trick doesn't work.\n  //\n  // So if PPR is enabled, and dynamicIO is not, we have to be conservative and\n  // assume all segments are partial.\n  //\n  // TODO: When PPR is on, we can at least optimize the case where the entire\n  // page is static. Either by passing that as an argument to this function, or\n  // by setting a header on the response like the we do for full page RSC\n  // prefetches today. The latter approach might be simpler since it requires\n  // less plumbing, and the client has to check the header regardless to see if\n  // PPR is enabled.\n  const shouldAssumePartialData =\n    renderOpts.experimental.isRoutePPREnabled === true && // PPR is enabled\n    !renderOpts.experimental.dynamicIO // dynamicIO is disabled\n\n  const staleTime = prerenderStore.stale\n  return await ComponentMod.collectSegmentData(\n    shouldAssumePartialData,\n    fullPageDataBuffer,\n    staleTime,\n    clientReferenceManifest.clientModules as ManifestNode,\n    serverConsumerManifest,\n    fallbackRouteParams\n  )\n}\n"],"names":["renderToHTMLOrFlight","warmFlightResponse","flightDataPathHeadKey","getFlightViewportKey","requestId","getFlightMetadataKey","parseRequestHeaders","headers","options","isDevWarmupRequest","isDevWarmup","isPrefetchRequest","NEXT_ROUTER_PREFETCH_HEADER","toLowerCase","undefined","isHmrRefresh","NEXT_HMR_REFRESH_HEADER","isRSCRequest","RSC_HEADER","shouldProvideFlightRouterState","isRoutePPREnabled","flightRouterState","parseAndValidateFlightRouterState","NEXT_ROUTER_STATE_TREE_HEADER","isRouteTreePrefetchRequest","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","csp","nonce","getScriptNonceFromHeader","previouslyRevalidatedTags","getPreviouslyRevalidatedTags","previewModeId","createNotFoundLoaderTree","loaderTree","components","children","PAGE_SEGMENT_KEY","page","makeGetDynamicParamFromSegment","params","pagePath","fallbackRouteParams","getDynamicParamFromSegment","segment","segmentParam","getSegmentParam","key","param","value","has","get","Array","isArray","map","i","encodeURIComponent","isCatchall","type","isOptionalCatchall","dynamicParamType","dynamicParamTypes","treeSegment","split","slice","flatMap","pathSegment","parseParameter","join","getShortDynamicParamType","NonIndex","statusCode","isPossibleServerAction","is404Page","isInvalidStatusCode","meta","name","content","generateDynamicRSCPayload","ctx","flightData","componentMod","tree","createMetadataComponents","MetadataBoundary","ViewportBoundary","appUsingSizeAdjustment","query","workStore","url","serveStreamingMetadata","renderOpts","skipFlight","preloadCallbacks","ViewportTree","MetadataTree","getViewportReady","getMetadataReady","StreamingMetadataOutlet","parsedQuery","metadataContext","createTrackedMetadataContext","pathname","walkTreeWithFlightRouterState","loaderTreeToFilter","parentParams","rscHead","React","Fragment","res","injectedCSS","Set","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","path","actionResult","a","f","b","sharedContext","buildId","S","isStaticGeneration","createErrorContext","renderSource","routerKind","routePath","routeType","revalidateReason","getRevalidateReason","generateDynamicFlightRenderResult","req","requestStore","onFlightDataRenderError","err","onInstrumentationRequestError","onError","createFlightReactServerErrorHandler","dev","RSCPayload","workUnitAsyncStorage","run","process","env","NODE_ENV","experimental","dynamicIO","resolveValidation","validationOutlet","createValidationOutlet","_validation","spawnDynamicValidationInDev","clientReferenceManifest","route","flightReadableStream","renderToReadableStream","clientModules","temporaryReferences","FlightRenderResult","fetchMetrics","warmupDevRender","implicitTags","InvariantError","rootParams","getRootParams","prerenderResumeDataCache","createPrerenderResumeDataCache","renderController","AbortController","prerenderController","cacheSignal","CacheSignal","prerenderStore","phase","renderSignal","signal","controller","dynamicTracking","revalidate","INFINITE_CACHE","expire","stale","tags","hmrRefreshHash","cookies","NEXT_HMR_REFRESH_HASH_COOKIE","rscPayload","cacheReady","abort","devRenderResumeDataCache","createRenderResumeDataCache","prepareInitialCanonicalUrl","search","getRSCPayload","is404","missingSlots","GlobalError","initialTree","createFlightRouterStateFromLoaderTree","errorType","seedData","createComponentTree","authInterrupts","varyHeader","getHeader","couldBeIntercepted","includes","NEXT_URL","initialHead","globalErrorStyles","getGlobalErrorStyles","isPossiblyPartialHead","P","Preloads","p","assetPrefix","c","m","G","s","postponed","forEach","preloadFn","getErrorRSCPayload","ssrError","createMetadataContext","metadata","isError","Error","html","id","head","body","template","data-next-error-message","message","data-next-error-digest","digest","data-next-error-stack","stack","App","reactServerStream","preinitScripts","ServerInsertedHTMLProvider","ServerInsertedMetadataProvider","gracefullyDegrade","response","use","useFlightStream","initialState","createInitialRouterState","navigatedAt","initialFlightData","initialCanonicalUrlParts","initialParallelRoutes","Map","location","prerendered","actionQueue","createMutableActionQueue","HeadManagerContext","require","Provider","appDir","AppRouter","globalErrorComponentAndStyles","ErrorApp","renderToHTMLOrFlightImpl","parsedRequestHeaders","requestEndedState","postponedState","serverComponentsHmrCache","isNotFoundPath","requestTimestamp","Date","now","serverActionsManifest","ComponentMod","nextFontManifest","serverActions","enableTainting","__next_app__","instrumented","wrapClientComponentLoader","globalThis","__next_require__","__next_chunk_load__","args","loadingChunk","loadChunk","trackChunkLoading","URL","setIsrStatus","NEXT_RUNTIME","isNodeNextRequest","originalRequest","on","ended","metrics","getClientComponentLoaderMetrics","reset","getTracer","startSpan","NextNodeServerSpan","clientComponentLoading","startTime","clientComponentLoadStart","attributes","clientComponentLoadCount","end","clientComponentLoadTimes","appUsingSizeAdjust","serverModuleMap","createServerModuleMap","setReferenceManifestsSingleton","patchFetch","taintObjectReference","stripInternalQueries","crypto","randomUUID","nanoid","isPossibleActionRequest","getIsPossibleServerAction","getImplicitTags","isPrefetch","setRootSpanAttribute","prerenderToStreamWithTracing","wrap","AppRenderSpan","getBodyResult","spanName","prerenderToStream","dynamicAccess","accessedDynamicData","isDebugDynamicAccesses","warn","access","formatDynamicAPIAccesses","invalidUsageError","digestErrorsMap","size","buildFailingError","values","next","ssrErrors","length","find","isUserLandError","pendingRevalidates","pendingRevalidateWrites","pendingRevalidatedTags","pendingPromise","executeRevalidates","finally","NEXT_PRIVATE_DEBUG_CACHE","console","log","waitUntil","collectedTags","fetchTags","staleHeader","String","collectedStale","setHeader","NEXT_ROUTER_STALE_TIME_HEADER","forceStatic","collectedRevalidate","cacheControl","collectedExpire","staticBailoutInfo","description","dynamicUsageDescription","dynamicUsageStack","RenderResult","streamToString","stream","renderResumeDataCache","createRequestStoreForRender","onUpdateCookies","previewProps","usedDynamic","forceDynamic","renderToStreamWithTracing","renderToStream","formState","actionRequestResult","handleAction","generateFlight","notFoundLoaderTree","result","assignMetadata","parseRelativeUrl","parsePostponedState","createWorkStore","routeModule","definition","workAsyncStorage","renderServerInsertedHTML","createServerInsertedHTML","getServerInsertedMetadata","createServerInsertedMetadata","tracingMetadata","getTracedMetadata","getTracePropagationData","clientTraceMetadata","polyfills","buildManifest","polyfillFiles","filter","polyfill","endsWith","src","getAssetQueryString","integrity","subresourceIntegrityManifest","crossOrigin","noModule","bootstrapScript","getRequiredScripts","reactServerErrorsByDigest","silenceLogger","onHTMLRenderRSCError","serverComponentsErrorHandler","createHTMLReactServerErrorHandler","nextExport","onHTMLRenderSSRError","allCapturedErrors","htmlRendererErrorHandler","createHTMLErrorHandler","reactServerResult","bind","appendHeader","scheduleInSequentialTasks","prerenderPhase","environmentName","filterStackFrame","_functionName","startsWith","ReactServerResult","waitAtLeastOneReactRenderTask","DynamicState","DATA","inlinedReactServerDataStream","createInlinedDataReadableStream","tee","chainStreams","createDocumentClosingStream","getPostponedFromState","resume","htmlStream","botType","getServerInsertedHTML","makeGetServerInsertedHTML","serverCapturedErrors","basePath","continueDynamicHTMLResume","inlinedDataStream","consume","onHeaders","maxHeadersLength","reactMaxHeadersLength","bootstrapScripts","generateStaticHTML","supportsDynamicResponse","shouldWaitOnAllReady","validateRootLayout","continueFizzStream","isStaticGenBailoutError","shouldBailoutToCSR","isBailoutToCSRError","getStackWithoutErrorMessage","error","reason","isHTTPAccessFallbackError","getAccessFallbackHTTPStatus","getAccessFallbackErrorTypeByStatus","isRedirectError","getRedirectStatusCodeFromError","redirectUrl","addPathPrefix","getURLFromRedirectError","Headers","appendMutableCookies","mutableCookies","from","errorPreinitScripts","errorBootstrapScript","errorRSCPayload","errorServerStream","fizzStream","renderToInitialFizzStream","ReactDOMServer","element","streamOptions","finalErr","bailOnRootNotFound","outlet","Promise","resolve","isNotFound","initialServerPrerenderController","initialServerRenderController","initialServerPrerenderStore","initialClientController","initialClientPrerenderStore","firstAttemptRSCPayload","initialServerStream","getDigestForWellKnownError","aborted","NEXT_DEBUG_BUILD","__NEXT_VERBOSE_LOGGING","printDebugThrownValueForProspectiveRender","warmupStream","renderStream","prerender","pendingInitialClientResult","catch","finalServerController","serverDynamicTracking","createDynamicTrackingState","finalServerPrerenderStore","finalClientController","clientDynamicTracking","dynamicValidation","createDynamicValidationState","finalClientPrerenderStore","finalServerPayload","serverPrerenderStreamResult","prerenderServerWithPhases","isUseCacheTimeoutError","isPrerenderInterruptedError","rootDidError","serverPhasedStream","asPhasedStream","preludeIsEmpty","prelude","unprocessedPrelude","prerenderClientWithPhases","errorInfo","dynamicErrors","push","componentStack","trackAllowedDynamicAccess","assertExhausted","processPrelude","LogDynamicValidation","throwIfDisallowedDynamic","shouldGenerateStaticFlightData","reactServerPrerenderResult","setMetadataHeader","item","initialServerPayload","pendingInitialServerResult","onPostpone","initialServerResult","createReactServerPrerenderResult","asStream","prerenderAndAbortInSequentialTasks","asUnclosingStream","serverIsDynamic","finalRenderPrerenderStore","finalAttemptRSCPayload","prerenderIsPending","prerenderResult","clientIsDynamic","doNotThrowOnEmptyStaticShell","streamToBuffer","segmentData","collectSegmentData","getDynamicHTMLPostponedState","getDynamicDataPostponedState","continueDynamicPrerender","consumeDynamicAccess","StaticGenBailoutError","foreverStream","ReadableStream","resumeStream","JSON","parse","stringify","createPostponedAbortSignal","continueStaticPrerender","consumeAsStream","cache","incrementalCache","processed","dynamicReason","getFirstDynamicReason","DynamicServerError","reactServerPrerenderStore","createReactServerPrerenderResultFromRender","ssrPrerenderStore","dynamicAccesses","prerenderLegacyStore","isDynamicServerError","flightStream","ServerPrerenderStreamResult","loadingChunks","chunkListeners","load","add","delete","createFromReadableStream","serverConsumerManifest","moduleLoading","moduleMap","ssrModuleMapping","r","modules","globalErrorModule","parseLoaderTree","styles","createComponentStylesAndScripts","filePath","getComponent","fullPageDataBuffer","clientSegmentCache","isEdgeRuntime","edgeRscModuleMapping","rscModuleMapping","shouldAssumePartialData","staleTime"],"mappings":"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","ignoreList":[0]}